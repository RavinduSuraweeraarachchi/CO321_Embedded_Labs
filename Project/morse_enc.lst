   1               		.file	"morse_enc.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	usart_init
  12               	usart_init:
  13               	.LFB7:
  14               		.file 1 "morse_enc.c"
   1:morse_enc.c   **** // CO321 Embedded Systems
   2:morse_enc.c   **** // Project: Morse Communicator
   3:morse_enc.c   **** // Part 1: Morse Code Encoder
   4:morse_enc.c   **** // Group 09
   5:morse_enc.c   **** 
   6:morse_enc.c   **** // Question:
   7:morse_enc.c   **** /*
   8:morse_enc.c   ****     PART 1: Morse Code Encoder
   9:morse_enc.c   ****     - Listen to the serial communication to the Arduino on USB Serial (9600 baud).
  10:morse_enc.c   ****     - Once receiving printable characters, convert them to Morse code.
  11:morse_enc.c   ****     - For every 
  12:morse_enc.c   ****         dot (.)
  13:morse_enc.c   ****         dash (-)
  14:morse_enc.c   ****         inter-symbol gap
  15:morse_enc.c   ****         inter-word gap
  16:morse_enc.c   ****         choose appropriate time intervals
  17:morse_enc.c   ****     - Light an LED and activate a piezo buzzer for each symbol
  18:morse_enc.c   ****     - Choose an appropriate frequency for the buzzer
  19:morse_enc.c   **** */
  20:morse_enc.c   **** 
  21:morse_enc.c   **** // Importing Necessary Libraries
  22:morse_enc.c   **** #include <avr/io.h>
  23:morse_enc.c   **** #include <avr/interrupt.h>
  24:morse_enc.c   **** #include "lcd.h"
  25:morse_enc.c   **** #include <string.h>
  26:morse_enc.c   **** #include <util/delay.h>
  27:morse_enc.c   **** 
  28:morse_enc.c   **** // For Serial Communication
  29:morse_enc.c   **** 
  30:morse_enc.c   **** // Define the Baud Rate
  31:morse_enc.c   **** #define BAUD_RATE 9600
  32:morse_enc.c   **** 
  33:morse_enc.c   **** // F_OSC for Calculation of UBRR Value
  34:morse_enc.c   **** #define F_OSC 16000000UL
  35:morse_enc.c   **** 
  36:morse_enc.c   **** // Equation to calculate UBRR value
  37:morse_enc.c   **** 
  38:morse_enc.c   **** /*
  39:morse_enc.c   **** We know that Desired Baud Rate (BAUD_RATE) = F_OSC / (16 * (X + 1))
  40:morse_enc.c   **** We need to subject X, which is the value to be loaded to UBRR register.
  41:morse_enc.c   **** X + 1 = F_OSC / (16 * BAUD_RATE)
  42:morse_enc.c   **** X = (F_OSC / (16 * BAUD_RATE)) - 1
  43:morse_enc.c   **** */
  44:morse_enc.c   **** 
  45:morse_enc.c   **** #define UBRR (F_OSC/16/BAUD_RATE)-1
  46:morse_enc.c   **** 
  47:morse_enc.c   **** 
  48:morse_enc.c   **** /*
  49:morse_enc.c   **** *******************************************************************************
  50:morse_enc.c   **** *******************************************************************************
  51:morse_enc.c   ****     For Serial Communication
  52:morse_enc.c   ****     Previously created functions are needed
  53:morse_enc.c   **** 
  54:morse_enc.c   **** *******************************************************************************
  55:morse_enc.c   **** *******************************************************************************
  56:morse_enc.c   **** */
  57:morse_enc.c   **** 
  58:morse_enc.c   **** void usart_init(void)
  59:morse_enc.c   **** {
  15               		.loc 1 59 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  60:morse_enc.c   **** 
  61:morse_enc.c   ****     /*
  62:morse_enc.c   ****     Enabling the Transmitter
  63:morse_enc.c   ****     */
  64:morse_enc.c   ****     UCSR0B |= (1 << TXEN0); // Enable transmitter
  21               		.loc 1 64 0
  22 0000 A1EC      		ldi r26,lo8(-63)
  23 0002 B0E0      		ldi r27,0
  24 0004 8C91      		ld r24,X
  25 0006 8860      		ori r24,lo8(8)
  26 0008 8C93      		st X,r24
  65:morse_enc.c   **** 
  66:morse_enc.c   ****     /*
  67:morse_enc.c   ****     Enabling the Receiver
  68:morse_enc.c   ****     */
  69:morse_enc.c   ****     UCSR0B |= (1 << RXEN0); // Enable receiver
  27               		.loc 1 69 0
  28 000a 8C91      		ld r24,X
  29 000c 8061      		ori r24,lo8(16)
  30 000e 8C93      		st X,r24
  70:morse_enc.c   **** 
  71:morse_enc.c   ****     /*
  72:morse_enc.c   ****     Setting the Baud Rate
  73:morse_enc.c   ****     */
  74:morse_enc.c   ****     UBRR0L = (uint8_t)(UBRR); // Load lower 8 bits of UBRR
  31               		.loc 1 74 0
  32 0010 87E6      		ldi r24,lo8(103)
  33 0012 8093 C400 		sts 196,r24
  75:morse_enc.c   ****     UBRR0H = (uint8_t)(UBRR >> 8); // Load upper 4 bits of UBRR
  34               		.loc 1 75 0
  35 0016 1092 C500 		sts 197,__zero_reg__
  76:morse_enc.c   ****     // It is alright to do this as last 4 bits of UBRR0H are reserved
  77:morse_enc.c   **** 
  78:morse_enc.c   ****     /*
  79:morse_enc.c   ****     Setting to Asynchronous Mode
  80:morse_enc.c   ****     */
  81:morse_enc.c   ****     UCSR0C &= ~(1<<UMSEL01);
  36               		.loc 1 81 0
  37 001a E2EC      		ldi r30,lo8(-62)
  38 001c F0E0      		ldi r31,0
  39 001e 8081      		ld r24,Z
  40 0020 8F77      		andi r24,lo8(127)
  41 0022 8083      		st Z,r24
  82:morse_enc.c   ****     UCSR0C &= ~(1<<UMSEL00);
  42               		.loc 1 82 0
  43 0024 8081      		ld r24,Z
  44 0026 8F7B      		andi r24,lo8(-65)
  45 0028 8083      		st Z,r24
  83:morse_enc.c   **** 
  84:morse_enc.c   ****     /*
  85:morse_enc.c   ****     Setting 8-bit data mode
  86:morse_enc.c   ****     */
  87:morse_enc.c   ****     UCSR0B &= ~(1 << UCSZ02); // Clear UCSZ02
  46               		.loc 1 87 0
  47 002a 8C91      		ld r24,X
  48 002c 8B7F      		andi r24,lo8(-5)
  49 002e 8C93      		st X,r24
  88:morse_enc.c   ****     UCSR0C |= (1 << UCSZ01) | (1 << UCSZ00); // Set UCSZ01 and UCSZ00
  50               		.loc 1 88 0
  51 0030 8081      		ld r24,Z
  52 0032 8660      		ori r24,lo8(6)
  53 0034 8083      		st Z,r24
  89:morse_enc.c   **** 
  90:morse_enc.c   ****     /*
  91:morse_enc.c   ****     Setting the Parity Mode   
  92:morse_enc.c   ****     */
  93:morse_enc.c   ****     
  94:morse_enc.c   ****     UCSR0C &= ~(1<<UPM00);
  54               		.loc 1 94 0
  55 0036 8081      		ld r24,Z
  56 0038 8F7E      		andi r24,lo8(-17)
  57 003a 8083      		st Z,r24
  95:morse_enc.c   ****     UCSR0C &= ~(1<<UPM01);
  58               		.loc 1 95 0
  59 003c 8081      		ld r24,Z
  60 003e 8F7D      		andi r24,lo8(-33)
  61 0040 8083      		st Z,r24
  96:morse_enc.c   **** 
  97:morse_enc.c   ****     /*    Setting the Stop Bit
  98:morse_enc.c   ****     */
  99:morse_enc.c   ****     UCSR0C &= ~(1 << USBS0); 
  62               		.loc 1 99 0
  63 0042 8081      		ld r24,Z
  64 0044 877F      		andi r24,lo8(-9)
  65 0046 8083      		st Z,r24
  66               	/* epilogue start */
 100:morse_enc.c   **** 
 101:morse_enc.c   **** }
  67               		.loc 1 101 0
  68 0048 0895      		ret
  69               		.cfi_endproc
  70               	.LFE7:
  72               	.global	usart_send
  74               	usart_send:
  75               	.LFB8:
 102:morse_enc.c   **** 
 103:morse_enc.c   **** void usart_send(char send_char)
 104:morse_enc.c   **** {
  76               		.loc 1 104 0
  77               		.cfi_startproc
  78               	/* prologue: function */
  79               	/* frame size = 0 */
  80               	/* stack size = 0 */
  81               	.L__stack_usage = 0
  82               	.LVL0:
  83               	.L3:
 105:morse_enc.c   ****     // We can wait until the transmit buffer is empty
 106:morse_enc.c   ****     // i.e. it waits as long as the UDRE0 bit is not set (0)
 107:morse_enc.c   ****     while (!(UCSR0A & (1 << UDRE0)));
  84               		.loc 1 107 0 discriminator 1
  85 004a 9091 C000 		lds r25,192
  86               		.loc 1 107 0 discriminator 1
  87 004e 95FF      		sbrs r25,5
  88 0050 00C0      		rjmp .L3
 108:morse_enc.c   **** 
 109:morse_enc.c   ****     // Load the character into the transmit buffer
 110:morse_enc.c   ****     UDR0 = send_char;   
  89               		.loc 1 110 0
  90 0052 8093 C600 		sts 198,r24
  91               	/* epilogue start */
 111:morse_enc.c   **** }
  92               		.loc 1 111 0
  93 0056 0895      		ret
  94               		.cfi_endproc
  95               	.LFE8:
  97               	.global	usart_receive
  99               	usart_receive:
 100               	.LFB9:
 112:morse_enc.c   **** 
 113:morse_enc.c   **** char usart_receive(void)
 114:morse_enc.c   **** {
 101               		.loc 1 114 0
 102               		.cfi_startproc
 103               	/* prologue: function */
 104               	/* frame size = 0 */
 105               	/* stack size = 0 */
 106               	.L__stack_usage = 0
 107               	.L7:
 115:morse_enc.c   ****     // Wait until a character is received
 116:morse_enc.c   ****     while (!(UCSR0A & (1 << RXC0)));
 108               		.loc 1 116 0 discriminator 1
 109 0058 8091 C000 		lds r24,192
 110               		.loc 1 116 0 discriminator 1
 111 005c 87FF      		sbrs r24,7
 112 005e 00C0      		rjmp .L7
 117:morse_enc.c   **** 
 118:morse_enc.c   ****     // Return the received character from the data register
 119:morse_enc.c   ****     return UDR0;
 113               		.loc 1 119 0
 114 0060 8091 C600 		lds r24,198
 115               	/* epilogue start */
 120:morse_enc.c   **** }
 116               		.loc 1 120 0
 117 0064 0895      		ret
 118               		.cfi_endproc
 119               	.LFE9:
 121               	.global	usart_send_string
 123               	usart_send_string:
 124               	.LFB10:
 121:morse_enc.c   **** 
 122:morse_enc.c   **** // This is a simple function to send a string over USART
 123:morse_enc.c   **** 
 124:morse_enc.c   **** void usart_send_string(char* str)
 125:morse_enc.c   **** {
 125               		.loc 1 125 0
 126               		.cfi_startproc
 127               	.LVL1:
 128 0066 CF93      		push r28
 129               	.LCFI0:
 130               		.cfi_def_cfa_offset 3
 131               		.cfi_offset 28, -2
 132 0068 DF93      		push r29
 133               	.LCFI1:
 134               		.cfi_def_cfa_offset 4
 135               		.cfi_offset 29, -3
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 2 */
 139               	.L__stack_usage = 2
 140 006a EC01      		movw r28,r24
 141               	.LVL2:
 142               	.L10:
 126:morse_enc.c   ****     // Loop through each character in the string until we reach the null terminator
 127:morse_enc.c   ****     while (*str != '\0')
 143               		.loc 1 127 0
 144 006c 8991      		ld r24,Y+
 145               	.LVL3:
 146 006e 8111      		cpse r24,__zero_reg__
 147 0070 00C0      		rjmp .L11
 148               	/* epilogue start */
 128:morse_enc.c   ****     {
 129:morse_enc.c   ****         usart_send(*str);
 130:morse_enc.c   ****         str++;
 131:morse_enc.c   ****     }
 132:morse_enc.c   **** }
 149               		.loc 1 132 0
 150 0072 DF91      		pop r29
 151 0074 CF91      		pop r28
 152               	.LVL4:
 153 0076 0895      		ret
 154               	.LVL5:
 155               	.L11:
 129:morse_enc.c   ****         str++;
 156               		.loc 1 129 0
 157 0078 0E94 0000 		call usart_send
 158               	.LVL6:
 159 007c 00C0      		rjmp .L10
 160               		.cfi_endproc
 161               	.LFE10:
 163               	.global	delay_timer0
 165               	delay_timer0:
 166               	.LFB11:
 133:morse_enc.c   **** 
 134:morse_enc.c   **** /*
 135:morse_enc.c   **** *******************************************************************************
 136:morse_enc.c   **** *******************************************************************************
 137:morse_enc.c   **** */
 138:morse_enc.c   **** 
 139:morse_enc.c   **** /*
 140:morse_enc.c   ****     We have created a Morse code map to convert characters to Morse code.
 141:morse_enc.c   ****     Each character is represented by a string of dots and dashes.
 142:morse_enc.c   ****     The map is indexed by the position of the character in the alphabet
 143:morse_enc.c   ****         Eg: A is at index 0, B is at index 1, .... Z is at index 25 etc.
 144:morse_enc.c   ****     
 145:morse_enc.c   ****     NOTE:
 146:morse_enc.c   ****     We have used char* because we need to access them using addresses (pointers).
 147:morse_enc.c   **** */
 148:morse_enc.c   **** const char* morseCodeMap[] = 
 149:morse_enc.c   **** {
 150:morse_enc.c   ****     ".-",    // A
 151:morse_enc.c   ****     "-...",  // B
 152:morse_enc.c   ****     "-.-.",  // C
 153:morse_enc.c   ****     "-..",   // D
 154:morse_enc.c   ****     ".",     // E
 155:morse_enc.c   ****     "..-.",  // F
 156:morse_enc.c   ****     "--.",   // G
 157:morse_enc.c   ****     "....",  // H
 158:morse_enc.c   ****     "..",    // I
 159:morse_enc.c   ****     ".---",  // J
 160:morse_enc.c   ****     "-.-",   // K
 161:morse_enc.c   ****     ".-..",  // L
 162:morse_enc.c   ****     "--",    // M
 163:morse_enc.c   ****     "-.",    // N
 164:morse_enc.c   ****     "---",   // O
 165:morse_enc.c   ****     ".--.",  // P
 166:morse_enc.c   ****     "--.-",  // Q
 167:morse_enc.c   ****     ".-.",   // R
 168:morse_enc.c   ****     "...",   // S
 169:morse_enc.c   ****     "-",     // T
 170:morse_enc.c   ****     "..-",   // U
 171:morse_enc.c   ****     "...-",  // V
 172:morse_enc.c   ****     ".--",   // W
 173:morse_enc.c   ****     "-..-",  // X
 174:morse_enc.c   ****     "-.--",  // Y
 175:morse_enc.c   ****     "--..",  // Z
 176:morse_enc.c   ****     "-----", // 0
 177:morse_enc.c   ****     ".----", // 1
 178:morse_enc.c   ****     "..---", // 2
 179:morse_enc.c   ****     "...--", // 3
 180:morse_enc.c   ****     "....-", // 4
 181:morse_enc.c   ****     ".....", // 5
 182:morse_enc.c   ****     "-....", // 6
 183:morse_enc.c   ****     "--...", // 7
 184:morse_enc.c   ****     "---..", // 8
 185:morse_enc.c   ****     "----."  // 9
 186:morse_enc.c   **** };
 187:morse_enc.c   **** 
 188:morse_enc.c   **** // Now we have added a Timer function
 189:morse_enc.c   **** // To be used for delays in the Morse code signaling
 190:morse_enc.c   **** 
 191:morse_enc.c   **** /*
 192:morse_enc.c   **** TIMER CALCULATIONS FOR TIMER0 CTC MODE:
 193:morse_enc.c   **** 
 194:morse_enc.c   **** XTAL = 16 MHz
 195:morse_enc.c   **** Prescaler = 64
 196:morse_enc.c   **** Timer0 is 8-bit, so max OCR0A = 255
 197:morse_enc.c   **** 
 198:morse_enc.c   **** Timer clock: 16 MHz / 64 = 250 kHz (1 count = 4 us)
 199:morse_enc.c   **** To achieve 100 ms delay:
 200:morse_enc.c   ****     - 100 ms / 4 us = 25,000 counts needed
 201:morse_enc.c   ****     - Set OCR0A = 249 for 1 ms per compare match (250 counts * 4 us = 1 ms)
 202:morse_enc.c   ****     - Loop 100 times for 100 ms total delay
 203:morse_enc.c   **** 
 204:morse_enc.c   **** This method uses CTC mode and is precise for short delays with 8-bit timers.
 205:morse_enc.c   **** */
 206:morse_enc.c   **** 
 207:morse_enc.c   **** // 100ms delay using Timer0 in CTC mode, prescaler 64
 208:morse_enc.c   **** void delay_timer0()
 209:morse_enc.c   **** {
 167               		.loc 1 209 0
 168               		.cfi_startproc
 169               	/* prologue: function */
 170               	/* frame size = 0 */
 171               	/* stack size = 0 */
 172               	.L__stack_usage = 0
 210:morse_enc.c   ****     // Set Timer0 to CTC mode (Clear Timer on Compare Match)
 211:morse_enc.c   ****     TCCR0A = (1 << WGM01); // CTC mode
 173               		.loc 1 211 0
 174 007e 82E0      		ldi r24,lo8(2)
 175 0080 84BD      		out 0x24,r24
 212:morse_enc.c   ****     TCCR0B = 0x00; // Stop timer for setup
 176               		.loc 1 212 0
 177 0082 15BC      		out 0x25,__zero_reg__
 213:morse_enc.c   **** 
 214:morse_enc.c   ****     // Calculate compare value for 100ms:
 215:morse_enc.c   ****     // OCR0A = (F_CPU / (Prescaler * Target Frequency)) - 1
 216:morse_enc.c   ****     // For 100ms: Target Frequency = 10Hz (period = 0.1s)
 217:morse_enc.c   ****     // OCR0A = (16,000,000 / (64 * 10)) - 1 = 24,999
 218:morse_enc.c   ****     // But Timer0 is 8-bit, max OCR0A = 255, so we need to loop
 219:morse_enc.c   ****     // Each count: 64 prescaler, 16MHz/64 = 250kHz, 1 count = 4us
 220:morse_enc.c   ****     // 100ms / 4us = 25,000 counts. So loop 100 times with OCR0A=249 (1ms per loop)
 221:morse_enc.c   ****     OCR0A = 249; // 1ms per compare match
 178               		.loc 1 221 0
 179 0084 89EF      		ldi r24,lo8(-7)
 180 0086 87BD      		out 0x27,r24
 222:morse_enc.c   **** 
 223:morse_enc.c   ****     // Set prescaler to 64 and start the timer
 224:morse_enc.c   ****     TCCR0B = (1 << CS01) | (1 << CS00); // Prescaler 64
 181               		.loc 1 224 0
 182 0088 83E0      		ldi r24,lo8(3)
 183 008a 85BD      		out 0x25,r24
 184               	.LVL7:
 185 008c 84E6      		ldi r24,lo8(100)
 186 008e 90E0      		ldi r25,0
 187               	.LVL8:
 188               	.L14:
 189               	.LBB2:
 225:morse_enc.c   **** 
 226:morse_enc.c   ****     // Wait for 100ms by looping 100 times
 227:morse_enc.c   ****     for (uint16_t i = 0; i < 100; i++) 
 228:morse_enc.c   ****     { 
 229:morse_enc.c   ****         // 100ms total
 230:morse_enc.c   ****         // Clear compare match flag
 231:morse_enc.c   ****         TIFR0 |= (1 << OCF0A);
 190               		.loc 1 231 0
 191 0090 A99A      		sbi 0x15,1
 192               	.L13:
 232:morse_enc.c   **** 
 233:morse_enc.c   ****         // Wait for compare match
 234:morse_enc.c   ****         while ((TIFR0 & (1 << OCF0A)) == 0);
 193               		.loc 1 234 0 discriminator 1
 194 0092 A99B      		sbis 0x15,1
 195 0094 00C0      		rjmp .L13
 196               	.LVL9:
 197 0096 0197      		sbiw r24,1
 198               	.LVL10:
 227:morse_enc.c   ****     { 
 199               		.loc 1 227 0 discriminator 2
 200 0098 01F4      		brne .L14
 201               	.LBE2:
 235:morse_enc.c   ****     }
 236:morse_enc.c   **** 
 237:morse_enc.c   ****     // Stop the timer
 238:morse_enc.c   ****     TCCR0B = 0x00;
 202               		.loc 1 238 0
 203 009a 15BC      		out 0x25,__zero_reg__
 239:morse_enc.c   ****     TCCR0A = 0x00;
 204               		.loc 1 239 0
 205 009c 14BC      		out 0x24,__zero_reg__
 206               	/* epilogue start */
 240:morse_enc.c   **** }
 207               		.loc 1 240 0
 208 009e 0895      		ret
 209               		.cfi_endproc
 210               	.LFE11:
 212               	.global	delay_100ms_units
 214               	delay_100ms_units:
 215               	.LFB12:
 241:morse_enc.c   **** 
 242:morse_enc.c   **** /*
 243:morse_enc.c   ****     Why CTC?
 244:morse_enc.c   ****     CTC (Clear Timer on Compare Match) mode is used 
 245:morse_enc.c   ****     because it allows the timer to reset automatically 
 246:morse_enc.c   ****     when it reaches a specified value (OCR1A).  
 247:morse_enc.c   **** 
 248:morse_enc.c   **** */
 249:morse_enc.c   **** 
 250:morse_enc.c   **** /*
 251:morse_enc.c   **** Defining hardware pins and time intervals for Morse code symbols
 252:morse_enc.c   **** 
 253:morse_enc.c   **** */
 254:morse_enc.c   **** 
 255:morse_enc.c   **** // LED for showing the morse code
 256:morse_enc.c   **** #define LED_DDR  DDRB
 257:morse_enc.c   **** #define LED_PORT PORTB
 258:morse_enc.c   **** #define LED_PIN  PB5 // Arduino Pin 13 (On-board LED)
 259:morse_enc.c   **** 
 260:morse_enc.c   **** // Buzzer for signaling Morse code
 261:morse_enc.c   **** #define BUZZER_DDR  DDRB
 262:morse_enc.c   **** #define BUZZER_PORT PORTB
 263:morse_enc.c   **** #define BUZZER_PIN  PB1 // Arduino Pin 9 (PB1)
 264:morse_enc.c   **** 
 265:morse_enc.c   **** // LED to show end of letter/number
 266:morse_enc.c   **** #define LED_LETTER_PIN PB2 // Arduino Pin 10
 267:morse_enc.c   **** 
 268:morse_enc.c   **** // LED to show end of word
 269:morse_enc.c   **** #define LED_WORD_PIN   PB3 // Arduino Pin 11
 270:morse_enc.c   **** 
 271:morse_enc.c   **** // LED to show end of sentence
 272:morse_enc.c   **** #define LED_SENT_PIN   PB4 // Arduino Pin 12
 273:morse_enc.c   **** 
 274:morse_enc.c   **** // Morse code timing (in milliseconds)
 275:morse_enc.c   **** // Reason for using define:
 276:morse_enc.c   **** // Just by changing DOT_DURATION, we can change the timing of the entire Morse code
 277:morse_enc.c   **** #define DOT_DURATION 200
 278:morse_enc.c   **** #define DASH_DURATION (3 * DOT_DURATION)
 279:morse_enc.c   **** #define SYMBOL_GAP_DURATION DOT_DURATION
 280:morse_enc.c   **** #define LETTER_GAP_DURATION (3 * DOT_DURATION)
 281:morse_enc.c   **** #define WORD_GAP_DURATION (7 * DOT_DURATION)
 282:morse_enc.c   **** 
 283:morse_enc.c   **** // This function is used to delay for a specified number of 100ms units
 284:morse_enc.c   **** // Since our delay timer is set to 100ms
 285:morse_enc.c   **** // we can use this function to create delays of orders of 100ms 
 286:morse_enc.c   **** 
 287:morse_enc.c   **** void delay_100ms_units(uint8_t units) 
 288:morse_enc.c   **** {   
 216               		.loc 1 288 0
 217               		.cfi_startproc
 218               	.LVL11:
 219 00a0 CF93      		push r28
 220               	.LCFI2:
 221               		.cfi_def_cfa_offset 3
 222               		.cfi_offset 28, -2
 223 00a2 DF93      		push r29
 224               	.LCFI3:
 225               		.cfi_def_cfa_offset 4
 226               		.cfi_offset 29, -3
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 2 */
 230               	.L__stack_usage = 2
 231 00a4 D82F      		mov r29,r24
 232               	.LVL12:
 233               	.LBB3:
 289:morse_enc.c   ****     for (uint8_t i = 0; i < units; i++) 
 234               		.loc 1 289 0
 235 00a6 C0E0      		ldi r28,0
 236               	.LVL13:
 237               	.L19:
 238               		.loc 1 289 0 is_stmt 0 discriminator 1
 239 00a8 CD13      		cpse r28,r29
 240 00aa 00C0      		rjmp .L20
 241               	/* epilogue start */
 242               	.LBE3:
 290:morse_enc.c   ****     {
 291:morse_enc.c   ****         delay_timer0();
 292:morse_enc.c   ****     }
 293:morse_enc.c   **** }
 243               		.loc 1 293 0 is_stmt 1
 244 00ac DF91      		pop r29
 245               	.LVL14:
 246 00ae CF91      		pop r28
 247               	.LVL15:
 248 00b0 0895      		ret
 249               	.LVL16:
 250               	.L20:
 251               	.LBB4:
 291:morse_enc.c   ****     }
 252               		.loc 1 291 0 discriminator 3
 253 00b2 0E94 0000 		call delay_timer0
 254               	.LVL17:
 289:morse_enc.c   ****     for (uint8_t i = 0; i < units; i++) 
 255               		.loc 1 289 0 discriminator 3
 256 00b6 CF5F      		subi r28,lo8(-(1))
 257               	.LVL18:
 258 00b8 00C0      		rjmp .L19
 259               	.LBE4:
 260               		.cfi_endproc
 261               	.LFE12:
 263               	.global	start_buzzer_pwm
 265               	start_buzzer_pwm:
 266               	.LFB13:
 294:morse_enc.c   **** 
 295:morse_enc.c   **** /*
 296:morse_enc.c   ****     SIGNAL_MORSE FUNCTION:
 297:morse_enc.c   **** 
 298:morse_enc.c   ****     We input a Morse code string (e.g., ".-") and signal it using the LED and buzzer.
 299:morse_enc.c   ****     We loop through each character in the Morse code string.
 300:morse_enc.c   ****     For each character, we turn on the LED and buzzer for the duration specified by the Morse code 
 301:morse_enc.c   ****     After signaling the character, we turn off the LED and buzzer.
 302:morse_enc.c   **** 
 303:morse_enc.c   **** */
 304:morse_enc.c   **** 
 305:morse_enc.c   **** 
 306:morse_enc.c   **** /*
 307:morse_enc.c   ****     A PWM FUNCTION TO START THE BUZZER
 308:morse_enc.c   **** 
 309:morse_enc.c   ****     CALCULATIONS:
 310:morse_enc.c   **** 
 311:morse_enc.c   ****     We need to set the PWM frequency to 1 kHz for the buzzer 
 312:morse_enc.c   ****     using Timer1 in CTC toggle mode (COM1A0 set).
 313:morse_enc.c   ****     The formula for the output frequency is:
 314:morse_enc.c   ****     f_OC1A = F_CPU / (2 * N * (1 + OCR1A))
 315:morse_enc.c   ****     Where:
 316:morse_enc.c   ****         F_CPU = 16 MHz
 317:morse_enc.c   ****         N = Prescaler (we will use 64)
 318:morse_enc.c   ****         OCR1A = Compare value for Timer1
 319:morse_enc.c   ****     To achieve 1 kHz:
 320:morse_enc.c   ****     1 kHz = 16 MHz / (2 * 64 * (1 + OCR1A))
 321:morse_enc.c   ****     Rearranging gives:
 322:morse_enc.c   ****     OCR1A = (F_CPU / (2 * N * f_OC1A)) - 1
 323:morse_enc.c   ****     For f_OC1A = 1000 Hz and N = 64:
 324:morse_enc.c   ****     OCR1A = (16,000,000 / (2 * 64 * 1000)) - 1 = 124
 325:morse_enc.c   ****     So we set OCR1A = 124 for a 1 kHz PWM frequency.
 326:morse_enc.c   **** */
 327:morse_enc.c   **** 
 328:morse_enc.c   **** void start_buzzer_pwm() 
 329:morse_enc.c   **** {
 267               		.loc 1 329 0
 268               		.cfi_startproc
 269               	/* prologue: function */
 270               	/* frame size = 0 */
 271               	/* stack size = 0 */
 272               	.L__stack_usage = 0
 330:morse_enc.c   ****     // Set PB1 as output
 331:morse_enc.c   ****     DDRB |= (1 << PB1);
 273               		.loc 1 331 0
 274 00ba 219A      		sbi 0x4,1
 332:morse_enc.c   **** 
 333:morse_enc.c   ****     // Toggle OC1A on compare match
 334:morse_enc.c   ****     TCCR1A = (1 << COM1A0);
 275               		.loc 1 334 0
 276 00bc 80E4      		ldi r24,lo8(64)
 277 00be 8093 8000 		sts 128,r24
 335:morse_enc.c   **** 
 336:morse_enc.c   ****     // CTC mode, prescaler 64
 337:morse_enc.c   ****     TCCR1B = (1 << WGM12) | (1 << CS11) | (1 << CS10);
 278               		.loc 1 337 0
 279 00c2 8BE0      		ldi r24,lo8(11)
 280 00c4 8093 8100 		sts 129,r24
 338:morse_enc.c   **** 
 339:morse_enc.c   ****     // Set OCR1A for 1 kHz: OCR1A = (F_CPU / (2 * 64 * 1000)) - 1 = 124
 340:morse_enc.c   ****     OCR1A = 124;
 281               		.loc 1 340 0
 282 00c8 8CE7      		ldi r24,lo8(124)
 283 00ca 90E0      		ldi r25,0
 284 00cc 9093 8900 		sts 136+1,r25
 285 00d0 8093 8800 		sts 136,r24
 286               	/* epilogue start */
 341:morse_enc.c   **** }
 287               		.loc 1 341 0
 288 00d4 0895      		ret
 289               		.cfi_endproc
 290               	.LFE13:
 292               	.global	stop_buzzer_pwm
 294               	stop_buzzer_pwm:
 295               	.LFB14:
 342:morse_enc.c   **** 
 343:morse_enc.c   **** /*
 344:morse_enc.c   ****     FUNCTION TO STOP THE BUZZER PWM
 345:morse_enc.c   **** */
 346:morse_enc.c   **** 
 347:morse_enc.c   **** void stop_buzzer_pwm() 
 348:morse_enc.c   **** {   
 296               		.loc 1 348 0
 297               		.cfi_startproc
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 0 */
 301               	.L__stack_usage = 0
 349:morse_enc.c   ****     // Clear TCCR1A and TCCR1B to stop PWM
 350:morse_enc.c   ****     TCCR1A = 0x00;
 302               		.loc 1 350 0
 303 00d6 1092 8000 		sts 128,__zero_reg__
 351:morse_enc.c   ****     TCCR1B = 0x00;
 304               		.loc 1 351 0
 305 00da 1092 8100 		sts 129,__zero_reg__
 352:morse_enc.c   **** 
 353:morse_enc.c   ****     // Ensure buzzer pin is low
 354:morse_enc.c   ****     BUZZER_PORT &= ~(1 << BUZZER_PIN);
 306               		.loc 1 354 0
 307 00de 2998      		cbi 0x5,1
 308               	/* epilogue start */
 355:morse_enc.c   **** }
 309               		.loc 1 355 0
 310 00e0 0895      		ret
 311               		.cfi_endproc
 312               	.LFE14:
 314               	.global	signal_morse
 316               	signal_morse:
 317               	.LFB15:
 356:morse_enc.c   **** 
 357:morse_enc.c   **** /*
 358:morse_enc.c   ****     SIGNAL_MORSE FUNCTION:
 359:morse_enc.c   **** 
 360:morse_enc.c   ****     This function takes a Morse code string and signals it using the LED and buzzer.
 361:morse_enc.c   ****     It turns on the LED and starts the PWM for the buzzer for the duration of each dot or dash.
 362:morse_enc.c   ****     After signaling, it turns off the LED and stops the PWM.
 363:morse_enc.c   **** 
 364:morse_enc.c   ****     NOTE:
 365:morse_enc.c   ****     Input for this function is a string of Morse code symbols (e.g., ".-.. . .-.. ---").
 366:morse_enc.c   ****     char* is used so that we can access the string using pointers.
 367:morse_enc.c   **** 
 368:morse_enc.c   **** */
 369:morse_enc.c   **** 
 370:morse_enc.c   **** void signal_morse(const char* morse_string) 
 371:morse_enc.c   **** {
 318               		.loc 1 371 0
 319               		.cfi_startproc
 320               	.LVL19:
 321 00e2 EF92      		push r14
 322               	.LCFI4:
 323               		.cfi_def_cfa_offset 3
 324               		.cfi_offset 14, -2
 325 00e4 FF92      		push r15
 326               	.LCFI5:
 327               		.cfi_def_cfa_offset 4
 328               		.cfi_offset 15, -3
 329 00e6 0F93      		push r16
 330               	.LCFI6:
 331               		.cfi_def_cfa_offset 5
 332               		.cfi_offset 16, -4
 333 00e8 1F93      		push r17
 334               	.LCFI7:
 335               		.cfi_def_cfa_offset 6
 336               		.cfi_offset 17, -5
 337 00ea CF93      		push r28
 338               	.LCFI8:
 339               		.cfi_def_cfa_offset 7
 340               		.cfi_offset 28, -6
 341 00ec DF93      		push r29
 342               	.LCFI9:
 343               		.cfi_def_cfa_offset 8
 344               		.cfi_offset 29, -7
 345               	/* prologue: function */
 346               	/* frame size = 0 */
 347               	/* stack size = 6 */
 348               	.L__stack_usage = 6
 349 00ee EC01      		movw r28,r24
 350               	.LVL20:
 351               	.LBB5:
 372:morse_enc.c   ****     // i variable to iterate through the Morse code string
 373:morse_enc.c   ****     int i = 0;
 374:morse_enc.c   **** 
 375:morse_enc.c   ****     // Loop through each character in the Morse code string
 376:morse_enc.c   ****     // Until we reach the null terminator
 377:morse_enc.c   **** 
 378:morse_enc.c   ****     while (morse_string[i] != '\0') 
 379:morse_enc.c   ****     {
 380:morse_enc.c   ****         // Turn ON the Signaling LED
 381:morse_enc.c   ****         LED_PORT |= (1 << LED_PIN);
 382:morse_enc.c   **** 
 383:morse_enc.c   ****         // Determine ON duration
 384:morse_enc.c   ****         // This code snippet checks whether
 385:morse_enc.c   ****         // the current character is a dot or a dash
 386:morse_enc.c   ****         // If it is a dot, we set the duration to DOT_DURATION
 387:morse_enc.c   ****         // If it is a dash, we set the duration to DASH_DURATION
 388:morse_enc.c   ****         uint16_t on_duration_ms = (morse_string[i] == '.') ? DOT_DURATION : DASH_DURATION;
 389:morse_enc.c   **** 
 390:morse_enc.c   ****         // Start PWM for buzzer
 391:morse_enc.c   ****         start_buzzer_pwm();
 392:morse_enc.c   **** 
 393:morse_enc.c   ****         // Wait for symbol duration using hardware timer (delay_timer0)
 394:morse_enc.c   ****         // units variable is used to determine how many 100ms units we need to wait
 395:morse_enc.c   ****         uint8_t units = on_duration_ms / 100;
 352               		.loc 1 395 0
 353 00f0 84E6      		ldi r24,lo8(100)
 354 00f2 E82E      		mov r14,r24
 355 00f4 F12C      		mov r15,__zero_reg__
 356               	.LVL21:
 357               	.L24:
 358               	.LBE5:
 378:morse_enc.c   ****     {
 359               		.loc 1 378 0
 360 00f6 8991      		ld r24,Y+
 361               	.LVL22:
 362 00f8 8111      		cpse r24,__zero_reg__
 363 00fa 00C0      		rjmp .L28
 364               	/* epilogue start */
 396:morse_enc.c   **** 
 397:morse_enc.c   ****         // Loop for the number of 100ms units
 398:morse_enc.c   ****         // This will create the required delay for the dot or dash
 399:morse_enc.c   ****         for (uint8_t t = 0; t < units; t++) 
 400:morse_enc.c   ****         {
 401:morse_enc.c   ****             delay_timer0();
 402:morse_enc.c   ****         }
 403:morse_enc.c   **** 
 404:morse_enc.c   ****         // Stop the Buzzer PWM
 405:morse_enc.c   ****         stop_buzzer_pwm();
 406:morse_enc.c   **** 
 407:morse_enc.c   ****         // Turn OFF LED
 408:morse_enc.c   ****         LED_PORT &= ~(1 << LED_PIN);
 409:morse_enc.c   **** 
 410:morse_enc.c   ****         // Inter-symbol gap
 411:morse_enc.c   ****         // This is to ensure that there is a gap between symbols
 412:morse_enc.c   ****         // We only add a gap if the next character is not the null terminator
 413:morse_enc.c   ****         // This prevents adding a gap after the last character
 414:morse_enc.c   ****         // If the next character is not null, we add a gap
 415:morse_enc.c   ****         if (morse_string[i+1] != '\0') 
 416:morse_enc.c   ****         {
 417:morse_enc.c   ****             delay_100ms_units(SYMBOL_GAP_DURATION / 100);
 418:morse_enc.c   ****         }
 419:morse_enc.c   **** 
 420:morse_enc.c   ****         // Increment the index
 421:morse_enc.c   ****         i++;
 422:morse_enc.c   ****     }
 423:morse_enc.c   **** }
 365               		.loc 1 423 0
 366 00fc DF91      		pop r29
 367 00fe CF91      		pop r28
 368               	.LVL23:
 369 0100 1F91      		pop r17
 370 0102 0F91      		pop r16
 371 0104 FF90      		pop r15
 372 0106 EF90      		pop r14
 373 0108 0895      		ret
 374               	.LVL24:
 375               	.L28:
 376               	.LBB7:
 381:morse_enc.c   **** 
 377               		.loc 1 381 0
 378 010a 2D9A      		sbi 0x5,5
 388:morse_enc.c   **** 
 379               		.loc 1 388 0
 380 010c FE01      		movw r30,r28
 381 010e 3197      		sbiw r30,1
 382 0110 8081      		ld r24,Z
 383 0112 08E5      		ldi r16,lo8(88)
 384 0114 12E0      		ldi r17,lo8(2)
 385 0116 8E32      		cpi r24,lo8(46)
 386 0118 01F4      		brne .L25
 387 011a 08EC      		ldi r16,lo8(-56)
 388 011c 10E0      		ldi r17,0
 389               	.L25:
 390               	.LVL25:
 391:morse_enc.c   **** 
 391               		.loc 1 391 0 discriminator 4
 392 011e 0E94 0000 		call start_buzzer_pwm
 393               	.LVL26:
 395:morse_enc.c   **** 
 394               		.loc 1 395 0 discriminator 4
 395 0122 C801      		movw r24,r16
 396 0124 B701      		movw r22,r14
 397 0126 0E94 0000 		call __udivmodhi4
 398 012a 062F      		mov r16,r22
 399               	.LVL27:
 400               	.LBB6:
 399:morse_enc.c   ****         {
 401               		.loc 1 399 0 discriminator 4
 402 012c 10E0      		ldi r17,0
 403               	.LVL28:
 404               	.L26:
 401:morse_enc.c   ****         }
 405               		.loc 1 401 0 discriminator 3
 406 012e 0E94 0000 		call delay_timer0
 407               	.LVL29:
 399:morse_enc.c   ****         {
 408               		.loc 1 399 0 discriminator 3
 409 0132 1F5F      		subi r17,lo8(-(1))
 410               	.LVL30:
 411 0134 1017      		cp r17,r16
 412 0136 00F0      		brlo .L26
 413               	.LBE6:
 405:morse_enc.c   **** 
 414               		.loc 1 405 0
 415 0138 0E94 0000 		call stop_buzzer_pwm
 416               	.LVL31:
 408:morse_enc.c   **** 
 417               		.loc 1 408 0
 418 013c 2D98      		cbi 0x5,5
 415:morse_enc.c   ****         {
 419               		.loc 1 415 0
 420 013e 8881      		ld r24,Y
 421 0140 8823      		tst r24
 422 0142 01F0      		breq .L24
 417:morse_enc.c   ****         }
 423               		.loc 1 417 0
 424 0144 82E0      		ldi r24,lo8(2)
 425 0146 0E94 0000 		call delay_100ms_units
 426               	.LVL32:
 427 014a 00C0      		rjmp .L24
 428               	.LBE7:
 429               		.cfi_endproc
 430               	.LFE15:
 432               	.global	letter_gap
 434               	letter_gap:
 435               	.LFB16:
 424:morse_enc.c   **** 
 425:morse_enc.c   **** /*
 426:morse_enc.c   ****     Function to handle the gap between letters
 427:morse_enc.c   ****     This function is called after signaling a letter
 428:morse_enc.c   ****     It creates a delay for the specified LETTER_GAP_DURATION
 429:morse_enc.c   **** */
 430:morse_enc.c   **** void letter_gap() 
 431:morse_enc.c   **** {
 436               		.loc 1 431 0
 437               		.cfi_startproc
 438               	/* prologue: function */
 439               	/* frame size = 0 */
 440               	/* stack size = 0 */
 441               	.L__stack_usage = 0
 432:morse_enc.c   ****     delay_100ms_units(LETTER_GAP_DURATION / 100);
 442               		.loc 1 432 0
 443 014c 86E0      		ldi r24,lo8(6)
 444 014e 0C94 0000 		jmp delay_100ms_units
 445               	.LVL33:
 446               		.cfi_endproc
 447               	.LFE16:
 449               	.global	word_gap
 451               	word_gap:
 452               	.LFB17:
 433:morse_enc.c   **** }
 434:morse_enc.c   **** 
 435:morse_enc.c   **** /*
 436:morse_enc.c   ****     Function to handle the gap between words
 437:morse_enc.c   ****     This function is called after signaling a word
 438:morse_enc.c   ****     It creates a delay for the specified WORD_GAP_DURATION
 439:morse_enc.c   **** */
 440:morse_enc.c   **** 
 441:morse_enc.c   **** void word_gap() 
 442:morse_enc.c   **** {
 453               		.loc 1 442 0
 454               		.cfi_startproc
 455               	/* prologue: function */
 456               	/* frame size = 0 */
 457               	/* stack size = 0 */
 458               	.L__stack_usage = 0
 443:morse_enc.c   ****     delay_100ms_units(WORD_GAP_DURATION / 100);
 459               		.loc 1 443 0
 460 0152 8EE0      		ldi r24,lo8(14)
 461 0154 0C94 0000 		jmp delay_100ms_units
 462               	.LVL34:
 463               		.cfi_endproc
 464               	.LFE17:
 466               	.global	get_morse_code
 468               	get_morse_code:
 469               	.LFB18:
 444:morse_enc.c   **** }
 445:morse_enc.c   **** 
 446:morse_enc.c   **** 
 447:morse_enc.c   **** /*
 448:morse_enc.c   ****     GET_MORSE_CODE FUNCTION:
 449:morse_enc.c   ****         Takes a readable character (A-Z, 0-9) 
 450:morse_enc.c   ****         Returns the corresponding Morse code string for the character
 451:morse_enc.c   **** */
 452:morse_enc.c   **** const char* get_morse_code(char c) 
 453:morse_enc.c   **** {
 470               		.loc 1 453 0
 471               		.cfi_startproc
 472               	.LVL35:
 473               	/* prologue: function */
 474               	/* frame size = 0 */
 475               	/* stack size = 0 */
 476               	.L__stack_usage = 0
 477 0158 E82F      		mov r30,r24
 454:morse_enc.c   ****     // For uppercase letters (A-Z)
 455:morse_enc.c   ****     if (c >= 'A' && c <= 'Z') 
 478               		.loc 1 455 0
 479 015a 8FEB      		ldi r24,lo8(-65)
 480               	.LVL36:
 481 015c 8E0F      		add r24,r30
 482 015e 8A31      		cpi r24,lo8(26)
 483 0160 00F4      		brsh .L37
 456:morse_enc.c   ****     {
 457:morse_enc.c   ****         return morseCodeMap[c - 'A'];
 484               		.loc 1 457 0
 485 0162 E154      		subi r30,65
 486 0164 FF0B      		sbc r31,r31
 487               	.LVL37:
 488               	.L41:
 458:morse_enc.c   ****     } 
 459:morse_enc.c   **** 
 460:morse_enc.c   ****     // For lowercase letters (a-z)
 461:morse_enc.c   ****     else if (c >= 'a' && c <= 'z') 
 462:morse_enc.c   ****     {
 463:morse_enc.c   ****         return morseCodeMap[c - 'a'];
 489               		.loc 1 463 0
 490 0166 EE0F      		lsl r30
 491 0168 FF1F      		rol r31
 492 016a E050      		subi r30,lo8(-(morseCodeMap))
 493 016c F040      		sbci r31,hi8(-(morseCodeMap))
 494 016e 8081      		ld r24,Z
 495 0170 9181      		ldd r25,Z+1
 496 0172 0895      		ret
 497               	.LVL38:
 498               	.L37:
 461:morse_enc.c   ****     {
 499               		.loc 1 461 0
 500 0174 8FE9      		ldi r24,lo8(-97)
 501 0176 8E0F      		add r24,r30
 502 0178 8A31      		cpi r24,lo8(26)
 503 017a 00F4      		brsh .L39
 504               		.loc 1 463 0
 505 017c E156      		subi r30,97
 506 017e FF0B      		sbc r31,r31
 507               	.LVL39:
 508 0180 00C0      		rjmp .L41
 509               	.LVL40:
 510               	.L39:
 511               	.LBB10:
 512               	.LBB11:
 464:morse_enc.c   ****     } 
 465:morse_enc.c   **** 
 466:morse_enc.c   ****     // For digits (0-9)
 467:morse_enc.c   ****     else if (c >= '0' && c <= '9') 
 513               		.loc 1 467 0
 514 0182 80ED      		ldi r24,lo8(-48)
 515 0184 8E0F      		add r24,r30
 468:morse_enc.c   ****     {
 469:morse_enc.c   ****         return morseCodeMap[26 + (c - '0')];
 516               		.loc 1 469 0
 517 0186 E651      		subi r30,22
 518 0188 FF0B      		sbc r31,r31
 519               	.LVL41:
 467:morse_enc.c   ****     {
 520               		.loc 1 467 0
 521 018a 8A30      		cpi r24,lo8(10)
 522 018c 00F0      		brlo .L41
 470:morse_enc.c   ****     } 
 471:morse_enc.c   **** 
 472:morse_enc.c   ****     // If the character is not in the range of A-Z, a-z, or 0-9
 473:morse_enc.c   ****     else 
 474:morse_enc.c   ****     {
 475:morse_enc.c   ****         return NULL;
 523               		.loc 1 475 0
 524 018e 90E0      		ldi r25,0
 525 0190 80E0      		ldi r24,0
 526               	/* epilogue start */
 527               	.LBE11:
 528               	.LBE10:
 476:morse_enc.c   ****     }
 477:morse_enc.c   **** }
 529               		.loc 1 477 0
 530 0192 0895      		ret
 531               		.cfi_endproc
 532               	.LFE18:
 534               		.section	.rodata.str1.1,"aMS",@progbits,1
 535               	.LC0:
 536 0000 4D6F 7273 		.string	"Morse Encoder"
 536      6520 456E 
 536      636F 6465 
 536      7200 
 537               	.LC1:
 538 000e 656E 6420 		.string	"end of sentence"
 538      6F66 2073 
 538      656E 7465 
 538      6E63 6500 
 539               		.section	.text.startup,"ax",@progbits
 540               	.global	main
 542               	main:
 543               	.LFB19:
 478:morse_enc.c   **** 
 479:morse_enc.c   **** 
 480:morse_enc.c   **** int main(void) 
 481:morse_enc.c   **** {
 544               		.loc 1 481 0
 545               		.cfi_startproc
 546 0000 CF93      		push r28
 547               	.LCFI10:
 548               		.cfi_def_cfa_offset 3
 549               		.cfi_offset 28, -2
 550 0002 DF93      		push r29
 551               	.LCFI11:
 552               		.cfi_def_cfa_offset 4
 553               		.cfi_offset 29, -3
 554 0004 CDB7      		in r28,__SP_L__
 555 0006 DEB7      		in r29,__SP_H__
 556               	.LCFI12:
 557               		.cfi_def_cfa_register 28
 558 0008 C058      		subi r28,-128
 559 000a D109      		sbc r29,__zero_reg__
 560               	.LCFI13:
 561               		.cfi_def_cfa_offset 132
 562 000c 0FB6      		in __tmp_reg__,__SREG__
 563 000e F894      		cli
 564 0010 DEBF      		out __SP_H__,r29
 565 0012 0FBE      		out __SREG__,__tmp_reg__
 566 0014 CDBF      		out __SP_L__,r28
 567               	/* prologue: function */
 568               	/* frame size = 128 */
 569               	/* stack size = 130 */
 570               	.L__stack_usage = 130
 482:morse_enc.c   ****     // Set LED and buzzer pins as output
 483:morse_enc.c   ****     LED_DDR |= (1 << LED_PIN) | (1 << LED_LETTER_PIN) | (1 << LED_WORD_PIN) | (1 << LED_SENT_PIN);
 571               		.loc 1 483 0
 572 0016 84B1      		in r24,0x4
 573 0018 8C63      		ori r24,lo8(60)
 574 001a 84B9      		out 0x4,r24
 484:morse_enc.c   ****     BUZZER_DDR |= (1 << BUZZER_PIN);
 575               		.loc 1 484 0
 576 001c 219A      		sbi 0x4,1
 485:morse_enc.c   **** 
 486:morse_enc.c   ****     // Ensure all LEDs and buzzer are off
 487:morse_enc.c   ****     LED_PORT &= ~(1 << LED_PIN);
 577               		.loc 1 487 0
 578 001e 2D98      		cbi 0x5,5
 488:morse_enc.c   ****     LED_PORT &= ~(1 << LED_LETTER_PIN);
 579               		.loc 1 488 0
 580 0020 2A98      		cbi 0x5,2
 489:morse_enc.c   ****     LED_PORT &= ~(1 << LED_WORD_PIN);
 581               		.loc 1 489 0
 582 0022 2B98      		cbi 0x5,3
 490:morse_enc.c   ****     LED_PORT &= ~(1 << LED_SENT_PIN);
 583               		.loc 1 490 0
 584 0024 2C98      		cbi 0x5,4
 491:morse_enc.c   ****     BUZZER_PORT &= ~(1 << BUZZER_PIN);
 585               		.loc 1 491 0
 586 0026 2998      		cbi 0x5,1
 492:morse_enc.c   **** 
 493:morse_enc.c   ****     // Initialize USART
 494:morse_enc.c   ****     usart_init();
 587               		.loc 1 494 0
 588 0028 0E94 0000 		call usart_init
 589               	.LVL42:
 495:morse_enc.c   **** 
 496:morse_enc.c   ****     // Initialize LCD
 497:morse_enc.c   ****     lcd_init(LCD_DISP_ON);
 590               		.loc 1 497 0
 591 002c 8CE0      		ldi r24,lo8(12)
 592 002e 0E94 0000 		call lcd_init
 593               	.LVL43:
 498:morse_enc.c   ****     lcd_clrscr();
 594               		.loc 1 498 0
 595 0032 0E94 0000 		call lcd_clrscr
 596               	.LVL44:
 499:morse_enc.c   ****     lcd_puts("Morse Encoder");
 597               		.loc 1 499 0
 598 0036 80E0      		ldi r24,lo8(.LC0)
 599 0038 90E0      		ldi r25,hi8(.LC0)
 600 003a 0E94 0000 		call lcd_puts
 601               	.LVL45:
 602               	.L59:
 500:morse_enc.c   ****     uint8_t lcd_col = 0;
 501:morse_enc.c   **** 
 502:morse_enc.c   ****     // Buffer for input
 503:morse_enc.c   ****     #define BUFFER_SIZE 128
 504:morse_enc.c   ****     char buffer[BUFFER_SIZE];
 505:morse_enc.c   **** 
 506:morse_enc.c   ****     // buf_idx for tracking buffer index
 507:morse_enc.c   ****     uint8_t buf_idx = 0;
 603               		.loc 1 507 0
 604 003e 10E0      		ldi r17,0
 605               	.LVL46:
 606               	.L43:
 607               	.LBB12:
 508:morse_enc.c   **** 
 509:morse_enc.c   ****     /*
 510:morse_enc.c   ****         MAIN LOOP:
 511:morse_enc.c   **** 
 512:morse_enc.c   ****         - Listen to the serial communication to the Arduino on USB Serial (9600 baud).
 513:morse_enc.c   ****         - While receiving characters, echo them back.
 514:morse_enc.c   ****         - If Enter is pressed, process the buffer:
 515:morse_enc.c   ****             - Clear the LCD screen.
 516:morse_enc.c   ****             - For each character in the buffer:
 517:morse_enc.c   ****                 - If it is a space, signal a word gap.
 518:morse_enc.c   ****                 - Otherwise, get the Morse code for the character and signal it.
 519:morse_enc.c   ****                 - Light up LED_LETTER_PIN briefly after signaling a letter.
 520:morse_enc.c   ****             - After processing the buffer, signal the end of the sentence with LED_SENT_PIN.
 521:morse_enc.c   ****         - Reset the buffer index after processing.
 522:morse_enc.c   ****         - Continue listening for new characters.
 523:morse_enc.c   **** 
 524:morse_enc.c   ****     */
 525:morse_enc.c   **** 
 526:morse_enc.c   ****     while (1) 
 527:morse_enc.c   ****     {
 528:morse_enc.c   ****         // Receive a character from USART
 529:morse_enc.c   ****         char c = usart_receive();
 608               		.loc 1 529 0
 609 0040 0E94 0000 		call usart_receive
 610               	.LVL47:
 611 0044 082F      		mov r16,r24
 612               	.LVL48:
 530:morse_enc.c   **** 
 531:morse_enc.c   ****         // Echo the received character back
 532:morse_enc.c   ****         usart_send(c);
 613               		.loc 1 532 0
 614 0046 0E94 0000 		call usart_send
 615               	.LVL49:
 533:morse_enc.c   **** 
 534:morse_enc.c   ****         // If Enter is pressed, process buffer
 535:morse_enc.c   ****         if (c == '\n' || c == '\r') 
 616               		.loc 1 535 0
 617 004a 0A30      		cpi r16,lo8(10)
 618 004c 01F0      		breq .L44
 619               		.loc 1 535 0 is_stmt 0 discriminator 1
 620 004e 0D30      		cpi r16,lo8(13)
 621 0050 01F0      		breq .+2
 622 0052 00C0      		rjmp .L45
 623               	.L44:
 624               	.LBB13:
 536:morse_enc.c   ****         {   
 537:morse_enc.c   ****             // Add the null terminator to the buffer
 538:morse_enc.c   ****             buffer[buf_idx] = '\0';
 625               		.loc 1 538 0 is_stmt 1
 626 0054 E1E0      		ldi r30,lo8(1)
 627 0056 F0E0      		ldi r31,0
 628 0058 EC0F      		add r30,r28
 629 005a FD1F      		adc r31,r29
 630 005c E10F      		add r30,r17
 631 005e F11D      		adc r31,__zero_reg__
 632 0060 1082      		st Z,__zero_reg__
 633               	.LVL50:
 539:morse_enc.c   **** 
 540:morse_enc.c   ****             // i for iterating through the buffer
 541:morse_enc.c   ****             uint8_t i = 0;
 542:morse_enc.c   **** 
 543:morse_enc.c   ****             // lcd_col for tracking the current column on the LCD
 544:morse_enc.c   ****             lcd_col = 0;
 545:morse_enc.c   **** 
 546:morse_enc.c   ****             // Clear the LCD screen
 547:morse_enc.c   ****             lcd_clrscr();
 634               		.loc 1 547 0
 635 0062 0E94 0000 		call lcd_clrscr
 636               	.LVL51:
 541:morse_enc.c   **** 
 637               		.loc 1 541 0
 638 0066 F12C      		mov r15,__zero_reg__
 639               	.LVL52:
 640               	.L46:
 548:morse_enc.c   **** 
 549:morse_enc.c   ****             // Iterate through the buffer until we reach the null terminator
 550:morse_enc.c   ****             while (buffer[i] != '\0') 
 641               		.loc 1 550 0
 642 0068 0F2D      		mov r16,r15
 643 006a 10E0      		ldi r17,0
 644 006c E1E0      		ldi r30,lo8(1)
 645 006e F0E0      		ldi r31,0
 646 0070 EC0F      		add r30,r28
 647 0072 FD1F      		adc r31,r29
 648 0074 E00F      		add r30,r16
 649 0076 F11F      		adc r31,r17
 650 0078 8081      		ld r24,Z
 651 007a 8111      		cpse r24,__zero_reg__
 652 007c 00C0      		rjmp .L51
 551:morse_enc.c   ****             {
 552:morse_enc.c   ****                 // If we reach a space character
 553:morse_enc.c   ****                 // We signal a word gap
 554:morse_enc.c   ****                 if (buffer[i] == ' ') 
 555:morse_enc.c   ****                 {
 556:morse_enc.c   ****                     // Word finished
 557:morse_enc.c   ****                     LED_PORT |= (1 << LED_WORD_PIN);
 558:morse_enc.c   **** 
 559:morse_enc.c   ****                     // Signal a word gap (function created above)
 560:morse_enc.c   ****                     word_gap();
 561:morse_enc.c   **** 
 562:morse_enc.c   ****                     // Turn off the word LED
 563:morse_enc.c   ****                     LED_PORT &= ~(1 << LED_WORD_PIN);
 564:morse_enc.c   **** 
 565:morse_enc.c   ****                     // Add space to LCD
 566:morse_enc.c   ****                     lcd_putc(' ');
 567:morse_enc.c   **** 
 568:morse_enc.c   ****                     // Increment the LCD column
 569:morse_enc.c   ****                     lcd_col++;
 570:morse_enc.c   ****                 } 
 571:morse_enc.c   **** 
 572:morse_enc.c   ****                 else 
 573:morse_enc.c   ****                 {   
 574:morse_enc.c   ****                     // If the character is not a space
 575:morse_enc.c   ****                     // We get the Morse code for the character
 576:morse_enc.c   ****                     // buffer[i] is the character (Eg: 'A', 'B', '1', etc.)
 577:morse_enc.c   ****                     // When we do get_morse_code(buffer[i]),
 578:morse_enc.c   ****                     // we get the corresponding Morse code string (e.g., ".-", "-...", etc.)
 579:morse_enc.c   ****                     const char* morse = get_morse_code(buffer[i]);
 580:morse_enc.c   **** 
 581:morse_enc.c   ****                     // If the Morse code is valid (not NULL)
 582:morse_enc.c   ****                     if (morse != NULL) 
 583:morse_enc.c   ****                     {
 584:morse_enc.c   ****                         // Now we can use the signal_morse function
 585:morse_enc.c   ****                         // Which takes a Morse code string and signals it
 586:morse_enc.c   ****                         signal_morse(morse);
 587:morse_enc.c   **** 
 588:morse_enc.c   ****                         // Light up LED_LETTER_PIN briefly after signaling a letter
 589:morse_enc.c   ****                         LED_PORT |= (1 << LED_LETTER_PIN);
 590:morse_enc.c   **** 
 591:morse_enc.c   ****                         // Delay to indicate the end of the letter
 592:morse_enc.c   ****                         delay_100ms_units(2);
 593:morse_enc.c   **** 
 594:morse_enc.c   ****                         // Turn off the LED_LETTER_PIN
 595:morse_enc.c   ****                         LED_PORT &= ~(1 << LED_LETTER_PIN);
 596:morse_enc.c   **** 
 597:morse_enc.c   ****                         // Letter gap to separate letters
 598:morse_enc.c   ****                         letter_gap();
 599:morse_enc.c   **** 
 600:morse_enc.c   ****                         // Clear the Screen
 601:morse_enc.c   ****                         lcd_clrscr();
 602:morse_enc.c   **** 
 603:morse_enc.c   ****                         /*
 604:morse_enc.c   ****                             Here, we print the Morse code string
 605:morse_enc.c   ****                             On the LCD screen
 606:morse_enc.c   ****                         */
 607:morse_enc.c   ****                        
 608:morse_enc.c   ****                         const char* morse_str = morse;
 609:morse_enc.c   **** 
 610:morse_enc.c   ****                         // Loop to iterate through the Morse code string
 611:morse_enc.c   ****                         // and print each character on the LCD
 612:morse_enc.c   ****                         for (uint8_t m = 0; morse_str[m] != '\0'; m++) 
 613:morse_enc.c   ****                         {   
 614:morse_enc.c   ****                             // Print char on LCD
 615:morse_enc.c   ****                             lcd_putc(morse_str[m]);
 616:morse_enc.c   ****                         }
 617:morse_enc.c   **** 
 618:morse_enc.c   ****                         // Print a space after the Morse code
 619:morse_enc.c   ****                         lcd_putc(' ');
 620:morse_enc.c   **** 
 621:morse_enc.c   ****                         // Print the original character on the LCD
 622:morse_enc.c   ****                         lcd_putc(buffer[i]);
 623:morse_enc.c   ****                     }
 624:morse_enc.c   ****                 }
 625:morse_enc.c   ****                 
 626:morse_enc.c   ****                 // Increment the buffer index
 627:morse_enc.c   ****                 i++;
 628:morse_enc.c   ****             }
 629:morse_enc.c   **** 
 630:morse_enc.c   ****             // End of sentence
 631:morse_enc.c   ****             lcd_clrscr();
 653               		.loc 1 631 0
 654 007e 0E94 0000 		call lcd_clrscr
 655               	.LVL53:
 632:morse_enc.c   ****             lcd_puts("end of sentence");
 656               		.loc 1 632 0
 657 0082 80E0      		ldi r24,lo8(.LC1)
 658 0084 90E0      		ldi r25,hi8(.LC1)
 659 0086 0E94 0000 		call lcd_puts
 660               	.LVL54:
 633:morse_enc.c   **** 
 634:morse_enc.c   ****             // Light up the LED_SENT_PIN to indicate end of sentence
 635:morse_enc.c   ****             LED_PORT |= (1 << LED_SENT_PIN);
 661               		.loc 1 635 0
 662 008a 2C9A      		sbi 0x5,4
 636:morse_enc.c   **** 
 637:morse_enc.c   ****             // Delay to indicate the end of the sentence
 638:morse_enc.c   ****             delay_100ms_units(10);
 663               		.loc 1 638 0
 664 008c 8AE0      		ldi r24,lo8(10)
 665 008e 0E94 0000 		call delay_100ms_units
 666               	.LVL55:
 639:morse_enc.c   **** 
 640:morse_enc.c   ****             // Turn off the LED_SENT_PIN
 641:morse_enc.c   ****             LED_PORT &= ~(1 << LED_SENT_PIN);
 667               		.loc 1 641 0
 668 0092 2C98      		cbi 0x5,4
 669               	.LVL56:
 670 0094 00C0      		rjmp .L59
 671               	.LVL57:
 672               	.L51:
 554:morse_enc.c   ****                 {
 673               		.loc 1 554 0
 674 0096 8032      		cpi r24,lo8(32)
 675 0098 01F4      		brne .L47
 557:morse_enc.c   **** 
 676               		.loc 1 557 0
 677 009a 2B9A      		sbi 0x5,3
 560:morse_enc.c   **** 
 678               		.loc 1 560 0
 679 009c 0E94 0000 		call word_gap
 680               	.LVL58:
 563:morse_enc.c   **** 
 681               		.loc 1 563 0
 682 00a0 2B98      		cbi 0x5,3
 566:morse_enc.c   **** 
 683               		.loc 1 566 0
 684 00a2 80E2      		ldi r24,lo8(32)
 685               	.L60:
 686               	.LBB14:
 687               	.LBB15:
 622:morse_enc.c   ****                     }
 688               		.loc 1 622 0
 689 00a4 0E94 0000 		call lcd_putc
 690               	.LVL59:
 691               	.L48:
 692               	.LBE15:
 693               	.LBE14:
 627:morse_enc.c   ****             }
 694               		.loc 1 627 0
 695 00a8 F394      		inc r15
 696               	.LVL60:
 697 00aa 00C0      		rjmp .L46
 698               	.L47:
 699               	.LBB19:
 579:morse_enc.c   **** 
 700               		.loc 1 579 0
 701 00ac 0E94 0000 		call get_morse_code
 702               	.LVL61:
 703 00b0 6C01      		movw r12,r24
 704               	.LVL62:
 582:morse_enc.c   ****                     {
 705               		.loc 1 582 0
 706 00b2 0097      		sbiw r24,0
 707 00b4 01F0      		breq .L48
 708               	.LBB18:
 586:morse_enc.c   **** 
 709               		.loc 1 586 0
 710 00b6 0E94 0000 		call signal_morse
 711               	.LVL63:
 589:morse_enc.c   **** 
 712               		.loc 1 589 0
 713 00ba 2A9A      		sbi 0x5,2
 592:morse_enc.c   **** 
 714               		.loc 1 592 0
 715 00bc 82E0      		ldi r24,lo8(2)
 716 00be 0E94 0000 		call delay_100ms_units
 717               	.LVL64:
 595:morse_enc.c   **** 
 718               		.loc 1 595 0
 719 00c2 2A98      		cbi 0x5,2
 598:morse_enc.c   **** 
 720               		.loc 1 598 0
 721 00c4 0E94 0000 		call letter_gap
 722               	.LVL65:
 601:morse_enc.c   **** 
 723               		.loc 1 601 0
 724 00c8 0E94 0000 		call lcd_clrscr
 725               	.LVL66:
 726               	.LBB16:
 612:morse_enc.c   ****                         {   
 727               		.loc 1 612 0
 728 00cc E12C      		mov r14,__zero_reg__
 729               	.LVL67:
 730               	.L49:
 612:morse_enc.c   ****                         {   
 731               		.loc 1 612 0 is_stmt 0 discriminator 1
 732 00ce F601      		movw r30,r12
 733 00d0 EE0D      		add r30,r14
 734 00d2 F11D      		adc r31,__zero_reg__
 735 00d4 8081      		ld r24,Z
 736 00d6 8111      		cpse r24,__zero_reg__
 737 00d8 00C0      		rjmp .L50
 738               	.LBE16:
 619:morse_enc.c   **** 
 739               		.loc 1 619 0 is_stmt 1
 740 00da 80E2      		ldi r24,lo8(32)
 741 00dc 0E94 0000 		call lcd_putc
 742               	.LVL68:
 622:morse_enc.c   ****                     }
 743               		.loc 1 622 0
 744 00e0 E1E0      		ldi r30,lo8(1)
 745 00e2 F0E0      		ldi r31,0
 746 00e4 EC0F      		add r30,r28
 747 00e6 FD1F      		adc r31,r29
 748 00e8 E00F      		add r30,r16
 749 00ea F11F      		adc r31,r17
 750 00ec 8081      		ld r24,Z
 751 00ee 00C0      		rjmp .L60
 752               	.L50:
 753               	.LBB17:
 615:morse_enc.c   ****                         }
 754               		.loc 1 615 0 discriminator 3
 755 00f0 0E94 0000 		call lcd_putc
 756               	.LVL69:
 612:morse_enc.c   ****                         {   
 757               		.loc 1 612 0 discriminator 3
 758 00f4 E394      		inc r14
 759               	.LVL70:
 760 00f6 00C0      		rjmp .L49
 761               	.LVL71:
 762               	.L45:
 763               	.LBE17:
 764               	.LBE18:
 765               	.LBE19:
 766               	.LBE13:
 642:morse_enc.c   **** 
 643:morse_enc.c   ****             // Reset the buffer index
 644:morse_enc.c   ****             buf_idx = 0;
 645:morse_enc.c   ****         } 
 646:morse_enc.c   ****         
 647:morse_enc.c   ****         /*
 648:morse_enc.c   ****             else is for handling non-printable characters
 649:morse_enc.c   ****             We ignore them
 650:morse_enc.c   ****         */
 651:morse_enc.c   ****         else 
 652:morse_enc.c   ****         {
 653:morse_enc.c   ****             // Buffer printable chars (ignore others)
 654:morse_enc.c   ****             // i.e. if the character is not within the printable ASCII range
 655:morse_enc.c   ****             // (32 to 126 inclusive)
 656:morse_enc.c   ****             if (buf_idx < BUFFER_SIZE - 1 && (c >= 32 && c <= 126)) 
 767               		.loc 1 656 0
 768 00f8 1F37      		cpi r17,lo8(127)
 769 00fa 00F0      		brlo .+2
 770 00fc 00C0      		rjmp .L43
 771               		.loc 1 656 0 is_stmt 0 discriminator 1
 772 00fe 80EE      		ldi r24,lo8(-32)
 773 0100 800F      		add r24,r16
 774 0102 8F35      		cpi r24,lo8(95)
 775 0104 00F0      		brlo .+2
 776 0106 00C0      		rjmp .L43
 777               	.LVL72:
 657:morse_enc.c   ****             {
 658:morse_enc.c   ****                 // Add the character to the buffer
 659:morse_enc.c   ****                 buffer[buf_idx++] = c;
 778               		.loc 1 659 0 is_stmt 1
 779 0108 E1E0      		ldi r30,lo8(1)
 780 010a F0E0      		ldi r31,0
 781 010c EC0F      		add r30,r28
 782 010e FD1F      		adc r31,r29
 783 0110 E10F      		add r30,r17
 784 0112 F11D      		adc r31,__zero_reg__
 785 0114 0083      		st Z,r16
 786 0116 1F5F      		subi r17,lo8(-(1))
 787               	.LVL73:
 788 0118 00C0      		rjmp .L43
 789               	.LBE12:
 790               		.cfi_endproc
 791               	.LFE19:
 793               	.global	morseCodeMap
 794               		.section	.rodata.str1.1
 795               	.LC2:
 796 001e 2E2D 00   		.string	".-"
 797               	.LC3:
 798 0021 2D2E 2E2E 		.string	"-..."
 798      00
 799               	.LC4:
 800 0026 2D2E 2D2E 		.string	"-.-."
 800      00
 801               	.LC5:
 802 002b 2D2E 2E00 		.string	"-.."
 803               	.LC6:
 804 002f 2E00      		.string	"."
 805               	.LC7:
 806 0031 2E2E 2D2E 		.string	"..-."
 806      00
 807               	.LC8:
 808 0036 2D2D 2E00 		.string	"--."
 809               	.LC9:
 810 003a 2E2E 2E2E 		.string	"...."
 810      00
 811               	.LC10:
 812 003f 2E2E 00   		.string	".."
 813               	.LC11:
 814 0042 2E2D 2D2D 		.string	".---"
 814      00
 815               	.LC12:
 816 0047 2D2E 2D00 		.string	"-.-"
 817               	.LC13:
 818 004b 2E2D 2E2E 		.string	".-.."
 818      00
 819               	.LC14:
 820 0050 2D2D 00   		.string	"--"
 821               	.LC15:
 822 0053 2D2E 00   		.string	"-."
 823               	.LC16:
 824 0056 2D2D 2D00 		.string	"---"
 825               	.LC17:
 826 005a 2E2D 2D2E 		.string	".--."
 826      00
 827               	.LC18:
 828 005f 2D2D 2E2D 		.string	"--.-"
 828      00
 829               	.LC19:
 830 0064 2E2D 2E00 		.string	".-."
 831               	.LC20:
 832 0068 2E2E 2E00 		.string	"..."
 833               	.LC21:
 834 006c 2D00      		.string	"-"
 835               	.LC22:
 836 006e 2E2E 2D00 		.string	"..-"
 837               	.LC23:
 838 0072 2E2E 2E2D 		.string	"...-"
 838      00
 839               	.LC24:
 840 0077 2E2D 2D00 		.string	".--"
 841               	.LC25:
 842 007b 2D2E 2E2D 		.string	"-..-"
 842      00
 843               	.LC26:
 844 0080 2D2E 2D2D 		.string	"-.--"
 844      00
 845               	.LC27:
 846 0085 2D2D 2E2E 		.string	"--.."
 846      00
 847               	.LC28:
 848 008a 2D2D 2D2D 		.string	"-----"
 848      2D00 
 849               	.LC29:
 850 0090 2E2D 2D2D 		.string	".----"
 850      2D00 
 851               	.LC30:
 852 0096 2E2E 2D2D 		.string	"..---"
 852      2D00 
 853               	.LC31:
 854 009c 2E2E 2E2D 		.string	"...--"
 854      2D00 
 855               	.LC32:
 856 00a2 2E2E 2E2E 		.string	"....-"
 856      2D00 
 857               	.LC33:
 858 00a8 2E2E 2E2E 		.string	"....."
 858      2E00 
 859               	.LC34:
 860 00ae 2D2E 2E2E 		.string	"-...."
 860      2E00 
 861               	.LC35:
 862 00b4 2D2D 2E2E 		.string	"--..."
 862      2E00 
 863               	.LC36:
 864 00ba 2D2D 2D2E 		.string	"---.."
 864      2E00 
 865               	.LC37:
 866 00c0 2D2D 2D2D 		.string	"----."
 866      2E00 
 867               		.data
 870               	morseCodeMap:
 871 0000 0000      		.word	.LC2
 872 0002 0000      		.word	.LC3
 873 0004 0000      		.word	.LC4
 874 0006 0000      		.word	.LC5
 875 0008 0000      		.word	.LC6
 876 000a 0000      		.word	.LC7
 877 000c 0000      		.word	.LC8
 878 000e 0000      		.word	.LC9
 879 0010 0000      		.word	.LC10
 880 0012 0000      		.word	.LC11
 881 0014 0000      		.word	.LC12
 882 0016 0000      		.word	.LC13
 883 0018 0000      		.word	.LC14
 884 001a 0000      		.word	.LC15
 885 001c 0000      		.word	.LC16
 886 001e 0000      		.word	.LC17
 887 0020 0000      		.word	.LC18
 888 0022 0000      		.word	.LC19
 889 0024 0000      		.word	.LC20
 890 0026 0000      		.word	.LC21
 891 0028 0000      		.word	.LC22
 892 002a 0000      		.word	.LC23
 893 002c 0000      		.word	.LC24
 894 002e 0000      		.word	.LC25
 895 0030 0000      		.word	.LC26
 896 0032 0000      		.word	.LC27
 897 0034 0000      		.word	.LC28
 898 0036 0000      		.word	.LC29
 899 0038 0000      		.word	.LC30
 900 003a 0000      		.word	.LC31
 901 003c 0000      		.word	.LC32
 902 003e 0000      		.word	.LC33
 903 0040 0000      		.word	.LC34
 904 0042 0000      		.word	.LC35
 905 0044 0000      		.word	.LC36
 906 0046 0000      		.word	.LC37
 907               		.text
 908               	.Letext0:
 909               		.file 2 "/usr/lib/avr/include/stdint.h"
 910               		.file 3 "lcd.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 morse_enc.c
         morse_enc.s:2      *ABS*:000000000000003e __SP_H__
         morse_enc.s:3      *ABS*:000000000000003d __SP_L__
         morse_enc.s:4      *ABS*:000000000000003f __SREG__
         morse_enc.s:5      *ABS*:0000000000000000 __tmp_reg__
         morse_enc.s:6      *ABS*:0000000000000001 __zero_reg__
         morse_enc.s:12     .text:0000000000000000 usart_init
         morse_enc.s:74     .text:000000000000004a usart_send
         morse_enc.s:99     .text:0000000000000058 usart_receive
         morse_enc.s:123    .text:0000000000000066 usart_send_string
         morse_enc.s:165    .text:000000000000007e delay_timer0
         morse_enc.s:214    .text:00000000000000a0 delay_100ms_units
         morse_enc.s:265    .text:00000000000000ba start_buzzer_pwm
         morse_enc.s:294    .text:00000000000000d6 stop_buzzer_pwm
         morse_enc.s:316    .text:00000000000000e2 signal_morse
         morse_enc.s:434    .text:000000000000014c letter_gap
         morse_enc.s:451    .text:0000000000000152 word_gap
         morse_enc.s:468    .text:0000000000000158 get_morse_code
         morse_enc.s:870    .data:0000000000000000 morseCodeMap
         morse_enc.s:542    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__udivmodhi4
lcd_init
lcd_clrscr
lcd_puts
lcd_putc
__do_copy_data
