   1               		.file	"Lab7_Ex3_G09.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	EEPROMwrite
  12               	EEPROMwrite:
  13               	.LFB7:
  14               		.file 1 "Lab7_Ex3_G09.c"
   1:Lab7_Ex3_G09.c **** // CO321 Embedded Systems
   2:Lab7_Ex3_G09.c **** // Lab 07: EEPROM / LCD / Keypad
   3:Lab7_Ex3_G09.c **** // AVR EEPROM programming in C language
   4:Lab7_Ex3_G09.c **** // Exercise 3: Caesar Cipher with EEPROM, LCD and Keypad
   5:Lab7_Ex3_G09.c **** // Group 09
   6:Lab7_Ex3_G09.c **** 
   7:Lab7_Ex3_G09.c **** // Question:
   8:Lab7_Ex3_G09.c **** /*
   9:Lab7_Ex3_G09.c **** 
  10:Lab7_Ex3_G09.c ****     In this exercise you have to develop an encryption system using the Caesar cipher.
  11:Lab7_Ex3_G09.c **** 
  12:Lab7_Ex3_G09.c ****     For this you have to use the LCD, keypad and the AVR MCU provided.
  13:Lab7_Ex3_G09.c ****     
  14:Lab7_Ex3_G09.c ****     When you run the program on the AVR, it should ask whether you want to encrypt or
  15:Lab7_Ex3_G09.c ****     change the secret key. You should be able to make the choice using the provided
  16:Lab7_Ex3_G09.c ****     keypad.
  17:Lab7_Ex3_G09.c ****     
  18:Lab7_Ex3_G09.c ****     Once the key is set, then it should ask for the plain text (for simplicity, weâ€™ll use 10
  19:Lab7_Ex3_G09.c ****     characters). 
  20:Lab7_Ex3_G09.c ****     
  21:Lab7_Ex3_G09.c ****     Also, the key should be stored in EEPROM. 
  22:Lab7_Ex3_G09.c ****     
  23:Lab7_Ex3_G09.c ****     The plain text should be entered using the keypad. 
  24:Lab7_Ex3_G09.c ****     
  25:Lab7_Ex3_G09.c ****     It should be shown on the LCD in real time. 
  26:Lab7_Ex3_G09.c ****     
  27:Lab7_Ex3_G09.c ****     Once the plain text is entered, it should be encrypted, and displayed on the LCD.
  28:Lab7_Ex3_G09.c ****     
  29:Lab7_Ex3_G09.c ****     You can fine tune the system in any manner you like. 
  30:Lab7_Ex3_G09.c ****     (e.g.: what happens after an encryption process? you can decide).
  31:Lab7_Ex3_G09.c **** 
  32:Lab7_Ex3_G09.c ****     Also no communication should be done with the PC other than uploading the program
  33:Lab7_Ex3_G09.c **** 
  34:Lab7_Ex3_G09.c **** */
  35:Lab7_Ex3_G09.c **** 
  36:Lab7_Ex3_G09.c **** // Importing Necessary Libraries
  37:Lab7_Ex3_G09.c **** #include <avr/io.h>
  38:Lab7_Ex3_G09.c **** #include <avr/interrupt.h>
  39:Lab7_Ex3_G09.c **** #include <util/delay.h>
  40:Lab7_Ex3_G09.c **** #include "lcd.h"
  41:Lab7_Ex3_G09.c **** #include <string.h>
  42:Lab7_Ex3_G09.c **** 
  43:Lab7_Ex3_G09.c **** // For Serial Communication
  44:Lab7_Ex3_G09.c **** 
  45:Lab7_Ex3_G09.c **** // Define the Baud Rate
  46:Lab7_Ex3_G09.c **** #define BAUD_RATE 9600
  47:Lab7_Ex3_G09.c **** 
  48:Lab7_Ex3_G09.c **** // F_OSC for Calculation of UBRR Value
  49:Lab7_Ex3_G09.c **** #define F_OSC 16000000UL
  50:Lab7_Ex3_G09.c **** 
  51:Lab7_Ex3_G09.c **** // Equation to calculate UBRR value
  52:Lab7_Ex3_G09.c **** 
  53:Lab7_Ex3_G09.c **** /*
  54:Lab7_Ex3_G09.c **** We know that Desired Baud Rate (BAUD_RATE) = F_OSC / (16 * (X + 1))
  55:Lab7_Ex3_G09.c **** We need to subject X, which is the value to be loaded to UBRR register.
  56:Lab7_Ex3_G09.c **** X + 1 = F_OSC / (16 * BAUD_RATE)
  57:Lab7_Ex3_G09.c **** X = (F_OSC / (16 * BAUD_RATE)) - 1
  58:Lab7_Ex3_G09.c **** */
  59:Lab7_Ex3_G09.c **** 
  60:Lab7_Ex3_G09.c **** #define UBRR (F_OSC/16/BAUD_RATE)-1
  61:Lab7_Ex3_G09.c **** 
  62:Lab7_Ex3_G09.c **** 
  63:Lab7_Ex3_G09.c **** // Function to write data to EEPROM
  64:Lab7_Ex3_G09.c **** 
  65:Lab7_Ex3_G09.c **** /*
  66:Lab7_Ex3_G09.c ****     WRITING TO EEPROM
  67:Lab7_Ex3_G09.c **** 
  68:Lab7_Ex3_G09.c ****     The following procedure should be followed to write data to the EEPROM:
  69:Lab7_Ex3_G09.c ****         1. Wait until a previous EEPROM write operation is complete.
  70:Lab7_Ex3_G09.c ****             * i.e. till EEPE bit becomes 0
  71:Lab7_Ex3_G09.c ****         2. Write the new EEPROM address
  72:Lab7_Ex3_G09.c ****             * EEARL and EEARH registers are used for this purpose
  73:Lab7_Ex3_G09.c ****         3. Write the new data to be written in the EEPROM at the address
  74:Lab7_Ex3_G09.c ****             * EEDR register is used for this purpose
  75:Lab7_Ex3_G09.c ****         4. Write a logic 1 to the EEMPE bit WHILE writing logic 0 to EEPE
  76:Lab7_Ex3_G09.c ****         5. Within FOUR CLOCK cycles, write a logic 1 to EEPE
  77:Lab7_Ex3_G09.c **** 
  78:Lab7_Ex3_G09.c **** */
  79:Lab7_Ex3_G09.c **** 
  80:Lab7_Ex3_G09.c **** // i.e. EEPROM write function takes two arguments:
  81:Lab7_Ex3_G09.c **** //      1. address: EEPROM address to write to
  82:Lab7_Ex3_G09.c **** //      2. data: data to be written to the EEPROM
  83:Lab7_Ex3_G09.c **** // There is no return value for this function
  84:Lab7_Ex3_G09.c **** 
  85:Lab7_Ex3_G09.c **** void EEPROMwrite(unsigned int address, char data)
  86:Lab7_Ex3_G09.c **** {
  15               		.loc 1 86 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LVL0:
  22               	.L2:
  87:Lab7_Ex3_G09.c ****     // Wait until the EEPROM is ready for a new write operation
  88:Lab7_Ex3_G09.c ****     while (EECR & (1 << EEPE));
  23               		.loc 1 88 0 discriminator 1
  24 0000 F999      		sbic 0x1f,1
  25 0002 00C0      		rjmp .L2
  89:Lab7_Ex3_G09.c **** 
  90:Lab7_Ex3_G09.c ****     // Set the EEPROM address
  91:Lab7_Ex3_G09.c ****     EEARL = address;
  26               		.loc 1 91 0
  27 0004 81BD      		out 0x21,r24
  92:Lab7_Ex3_G09.c ****     EEARH = address >> 8;
  28               		.loc 1 92 0
  29 0006 92BD      		out 0x22,r25
  93:Lab7_Ex3_G09.c **** 
  94:Lab7_Ex3_G09.c ****     // Set the data to be written
  95:Lab7_Ex3_G09.c ****     EEDR = data;
  30               		.loc 1 95 0
  31 0008 60BD      		out 0x20,r22
  96:Lab7_Ex3_G09.c **** 
  97:Lab7_Ex3_G09.c ****     // Writing logic 1 to EEMPE while EEPE is 0
  98:Lab7_Ex3_G09.c ****     EECR |= (1 << EEMPE);
  32               		.loc 1 98 0
  33 000a FA9A      		sbi 0x1f,2
  99:Lab7_Ex3_G09.c **** 
 100:Lab7_Ex3_G09.c ****     // Within four clock cycles, write logic 1 to EEPE to start the write operation
 101:Lab7_Ex3_G09.c ****     // We can start immediately after setting EEMPE
 102:Lab7_Ex3_G09.c ****     EECR |= (1 << EEPE);
  34               		.loc 1 102 0
  35 000c F99A      		sbi 0x1f,1
  36               	/* epilogue start */
 103:Lab7_Ex3_G09.c **** }
  37               		.loc 1 103 0
  38 000e 0895      		ret
  39               		.cfi_endproc
  40               	.LFE7:
  42               	.global	EEPROMread
  44               	EEPROMread:
  45               	.LFB8:
 104:Lab7_Ex3_G09.c **** 
 105:Lab7_Ex3_G09.c **** 
 106:Lab7_Ex3_G09.c **** // Function to read data from EEPROM
 107:Lab7_Ex3_G09.c **** 
 108:Lab7_Ex3_G09.c **** /*
 109:Lab7_Ex3_G09.c ****     READING FROM EEPROM
 110:Lab7_Ex3_G09.c **** 
 111:Lab7_Ex3_G09.c ****     The following procedure should be followed to read data from the EEPROM:
 112:Lab7_Ex3_G09.c ****         1. Wait until a previous EEPROM write operation is complete.
 113:Lab7_Ex3_G09.c ****             * i.e. till EEPE bit becomes 0
 114:Lab7_Ex3_G09.c ****         2. Write the new EEPROM address
 115:Lab7_Ex3_G09.c ****             * EEARL and EEARH registers are used for this purpose
 116:Lab7_Ex3_G09.c ****         3. Write a logic 1 to EERE bit to start the read operation
 117:Lab7_Ex3_G09.c ****         4. Read the data from the EEDR register
 118:Lab7_Ex3_G09.c **** 
 119:Lab7_Ex3_G09.c **** */
 120:Lab7_Ex3_G09.c **** 
 121:Lab7_Ex3_G09.c **** // i.e. EEPROM read function takes one argument:
 122:Lab7_Ex3_G09.c **** //      Address: EEPROM address to read from
 123:Lab7_Ex3_G09.c **** // Also there is a return value for this function:
 124:Lab7_Ex3_G09.c **** //      Data: data read from the EEPROM at the address
 125:Lab7_Ex3_G09.c **** //      which is a character
 126:Lab7_Ex3_G09.c **** 
 127:Lab7_Ex3_G09.c **** char EEPROMread(unsigned int address)
 128:Lab7_Ex3_G09.c **** {
  46               		.loc 1 128 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  52               	.LVL1:
  53               	.L5:
 129:Lab7_Ex3_G09.c ****     // Wait until the EEPROM is ready for a new write operation
 130:Lab7_Ex3_G09.c ****     while (EECR & (1 << EEPE));
  54               		.loc 1 130 0 discriminator 1
  55 0010 F999      		sbic 0x1f,1
  56 0012 00C0      		rjmp .L5
 131:Lab7_Ex3_G09.c **** 
 132:Lab7_Ex3_G09.c ****     // Set the EEPROM address
 133:Lab7_Ex3_G09.c ****     EEARL = address;
  57               		.loc 1 133 0
  58 0014 81BD      		out 0x21,r24
 134:Lab7_Ex3_G09.c ****     EEARH = address >> 8;
  59               		.loc 1 134 0
  60 0016 92BD      		out 0x22,r25
 135:Lab7_Ex3_G09.c **** 
 136:Lab7_Ex3_G09.c ****     // Start the read operation by writing logic 1 to EERE
 137:Lab7_Ex3_G09.c ****     EECR |= (1 << EERE);
  61               		.loc 1 137 0
  62 0018 F89A      		sbi 0x1f,0
 138:Lab7_Ex3_G09.c **** 
 139:Lab7_Ex3_G09.c ****     // Return the data read from the EEPROM
 140:Lab7_Ex3_G09.c ****     return EEDR;
  63               		.loc 1 140 0
  64 001a 80B5      		in r24,0x20
  65               	.LVL2:
  66               	/* epilogue start */
 141:Lab7_Ex3_G09.c **** }
  67               		.loc 1 141 0
  68 001c 0895      		ret
  69               		.cfi_endproc
  70               	.LFE8:
  72               	.global	caesar_cipher
  74               	caesar_cipher:
  75               	.LFB9:
 142:Lab7_Ex3_G09.c **** 
 143:Lab7_Ex3_G09.c **** 
 144:Lab7_Ex3_G09.c **** 
 145:Lab7_Ex3_G09.c **** /*
 146:Lab7_Ex3_G09.c **** *******************************************************************************
 147:Lab7_Ex3_G09.c **** ********************************************************************************
 148:Lab7_Ex3_G09.c ****     CAESAR CIPHER CODE
 149:Lab7_Ex3_G09.c **** *******************************************************************************
 150:Lab7_Ex3_G09.c **** *******************************************************************************
 151:Lab7_Ex3_G09.c **** 
 152:Lab7_Ex3_G09.c **** */
 153:Lab7_Ex3_G09.c **** 
 154:Lab7_Ex3_G09.c **** char caesar_cipher(char ch, uint8_t shift)
 155:Lab7_Ex3_G09.c **** {
  76               		.loc 1 155 0
  77               		.cfi_startproc
  78               	.LVL3:
  79               	/* prologue: function */
  80               	/* frame size = 0 */
  81               	/* stack size = 0 */
  82               	.L__stack_usage = 0
 156:Lab7_Ex3_G09.c ****     // If the character is an uppercase letter
 157:Lab7_Ex3_G09.c ****     if (ch >= 'A' && ch <= 'Z')
  83               		.loc 1 157 0
  84 001e 9FEB      		ldi r25,lo8(-65)
  85 0020 980F      		add r25,r24
  86 0022 9A31      		cpi r25,lo8(26)
  87 0024 00F4      		brsh .L8
 158:Lab7_Ex3_G09.c ****     {
 159:Lab7_Ex3_G09.c ****         // Shift the character by the specified positions
 160:Lab7_Ex3_G09.c ****         ch = ((ch - 'A' + shift) % 26) + 'A';
  88               		.loc 1 160 0
  89 0026 8154      		subi r24,65
  90 0028 990B      		sbc r25,r25
  91               	.LVL4:
  92 002a 860F      		add r24,r22
  93 002c 911D      		adc r25,__zero_reg__
  94 002e 6AE1      		ldi r22,lo8(26)
  95 0030 70E0      		ldi r23,0
  96               	.LVL5:
  97 0032 0E94 0000 		call __divmodhi4
  98 0036 8F5B      		subi r24,lo8(-(65))
  99               	.LVL6:
 161:Lab7_Ex3_G09.c ****         return ch;
 100               		.loc 1 161 0
 101 0038 0895      		ret
 102               	.LVL7:
 103               	.L8:
 104               	.LBB21:
 105               	.LBB22:
 162:Lab7_Ex3_G09.c ****     }
 163:Lab7_Ex3_G09.c **** 
 164:Lab7_Ex3_G09.c ****     // If the character is a lowercase letter
 165:Lab7_Ex3_G09.c ****     else if (ch >= 'a' && ch <= 'z')
 106               		.loc 1 165 0
 107 003a 9FE9      		ldi r25,lo8(-97)
 108 003c 980F      		add r25,r24
 109 003e 9A31      		cpi r25,lo8(26)
 110 0040 00F4      		brsh .L9
 166:Lab7_Ex3_G09.c ****     {
 167:Lab7_Ex3_G09.c ****         // Shift the character by the specified positions
 168:Lab7_Ex3_G09.c ****         ch = ((ch - 'a' + shift) % 26) + 'a';
 111               		.loc 1 168 0
 112 0042 8156      		subi r24,97
 113 0044 990B      		sbc r25,r25
 114               	.LVL8:
 115 0046 860F      		add r24,r22
 116 0048 911D      		adc r25,__zero_reg__
 117 004a 6AE1      		ldi r22,lo8(26)
 118 004c 70E0      		ldi r23,0
 119               	.LVL9:
 120 004e 0E94 0000 		call __divmodhi4
 121 0052 8F59      		subi r24,lo8(-(97))
 122               	.LVL10:
 123               	.L9:
 124               	/* epilogue start */
 125               	.LBE22:
 126               	.LBE21:
 169:Lab7_Ex3_G09.c ****         return ch;
 170:Lab7_Ex3_G09.c ****     }
 171:Lab7_Ex3_G09.c **** 
 172:Lab7_Ex3_G09.c ****     // We need a condition for all other characters
 173:Lab7_Ex3_G09.c ****     else
 174:Lab7_Ex3_G09.c ****     {
 175:Lab7_Ex3_G09.c ****         // Non-alphabetic characters remain unchanged
 176:Lab7_Ex3_G09.c ****         return ch;
 177:Lab7_Ex3_G09.c ****     }
 178:Lab7_Ex3_G09.c **** }
 127               		.loc 1 178 0
 128 0054 0895      		ret
 129               		.cfi_endproc
 130               	.LFE9:
 132               	.global	keypad_init
 134               	keypad_init:
 135               	.LFB10:
 179:Lab7_Ex3_G09.c **** 
 180:Lab7_Ex3_G09.c **** 
 181:Lab7_Ex3_G09.c **** /*
 182:Lab7_Ex3_G09.c **** *******************************************************************************
 183:Lab7_Ex3_G09.c **** ********************************************************************************
 184:Lab7_Ex3_G09.c ****     4x4 MATRIX KEYPAD CODE
 185:Lab7_Ex3_G09.c **** *******************************************************************************
 186:Lab7_Ex3_G09.c **** *******************************************************************************
 187:Lab7_Ex3_G09.c **** 
 188:Lab7_Ex3_G09.c ****     It initializes the keypad, scans for key presses, and returns the pressed key.
 189:Lab7_Ex3_G09.c ****     The keypad layout is defined in a 2D array.
 190:Lab7_Ex3_G09.c **** 
 191:Lab7_Ex3_G09.c ****     The keypad uses 4 rows and 4 columns, with rows set as outputs and columns as inputs.
 192:Lab7_Ex3_G09.c ****     When a key is pressed, it pulls the corresponding column low, allowing detection of the key.
 193:Lab7_Ex3_G09.c **** 
 194:Lab7_Ex3_G09.c **** */
 195:Lab7_Ex3_G09.c **** 
 196:Lab7_Ex3_G09.c **** // Keypad layout
 197:Lab7_Ex3_G09.c **** // This maps the layout of the keys on the keypad to characters.
 198:Lab7_Ex3_G09.c **** const char keymap[4][4] = {
 199:Lab7_Ex3_G09.c ****     {'1','2','3','A'},
 200:Lab7_Ex3_G09.c ****     {'4','5','6','B'},
 201:Lab7_Ex3_G09.c ****     {'7','8','9','C'},
 202:Lab7_Ex3_G09.c ****     {'*','0','#','D'}
 203:Lab7_Ex3_G09.c **** };
 204:Lab7_Ex3_G09.c **** 
 205:Lab7_Ex3_G09.c **** /*
 206:Lab7_Ex3_G09.c **** Row pins are as follows:
 207:Lab7_Ex3_G09.c ****     - Row 1 Pin: PD7 (Arduino Pin 7)
 208:Lab7_Ex3_G09.c ****     - Row 2 Pin: PD6 (Arduino Pin 6)
 209:Lab7_Ex3_G09.c ****     - Row 3 Pin: PB0 (Arduino Pin 8)
 210:Lab7_Ex3_G09.c ****     - Row 4 Pin: PB1 (Arduino Pin 9)
 211:Lab7_Ex3_G09.c **** 
 212:Lab7_Ex3_G09.c ****     define is used to define the row and column pins for the keypad
 213:Lab7_Ex3_G09.c ****     for the convenience of the code
 214:Lab7_Ex3_G09.c **** */
 215:Lab7_Ex3_G09.c **** 
 216:Lab7_Ex3_G09.c **** #define ROW1_PORT PORTD
 217:Lab7_Ex3_G09.c **** #define ROW1_DDR  DDRD
 218:Lab7_Ex3_G09.c **** #define ROW1_PIN  PD7    
 219:Lab7_Ex3_G09.c **** 
 220:Lab7_Ex3_G09.c **** #define ROW2_PORT PORTD
 221:Lab7_Ex3_G09.c **** #define ROW2_DDR  DDRD
 222:Lab7_Ex3_G09.c **** #define ROW2_PIN  PD6   
 223:Lab7_Ex3_G09.c **** 
 224:Lab7_Ex3_G09.c **** #define ROW3_PORT PORTB
 225:Lab7_Ex3_G09.c **** #define ROW3_DDR  DDRB
 226:Lab7_Ex3_G09.c **** #define ROW3_PIN  PB0    
 227:Lab7_Ex3_G09.c **** 
 228:Lab7_Ex3_G09.c **** #define ROW4_PORT PORTB
 229:Lab7_Ex3_G09.c **** #define ROW4_DDR  DDRB
 230:Lab7_Ex3_G09.c **** #define ROW4_PIN  PB1    
 231:Lab7_Ex3_G09.c **** 
 232:Lab7_Ex3_G09.c **** /*
 233:Lab7_Ex3_G09.c **** Column pins are as follows:
 234:Lab7_Ex3_G09.c ****     - Column 1 Pin: PB2 (Arduino Pin 10)
 235:Lab7_Ex3_G09.c ****     - Column 2 Pin: PB3 (Arduino Pin 11)
 236:Lab7_Ex3_G09.c ****     - Column 3 Pin: PB4 (Arduino Pin 12)
 237:Lab7_Ex3_G09.c ****     - Column 4 Pin: PB5 (Arduino Pin 13)
 238:Lab7_Ex3_G09.c **** 
 239:Lab7_Ex3_G09.c **** */
 240:Lab7_Ex3_G09.c **** #define COL1_PIN  PB2    // Arduino 10
 241:Lab7_Ex3_G09.c **** #define COL2_PIN  PB3    // Arduino 11
 242:Lab7_Ex3_G09.c **** #define COL3_PIN  PB4    // Arduino 12
 243:Lab7_Ex3_G09.c **** #define COL4_PIN  PB5    // Arduino 13
 244:Lab7_Ex3_G09.c **** 
 245:Lab7_Ex3_G09.c **** /*
 246:Lab7_Ex3_G09.c **** Initializtion:
 247:Lab7_Ex3_G09.c ****     To get the inputs from the keypad, we need to set the rows as outputs and columns as inputs.
 248:Lab7_Ex3_G09.c ****     The columns will have pull-up resistors enabled to ensure they read high when no key is pressed
 249:Lab7_Ex3_G09.c ****     When a key is pressed, it pulls the corresponding column low, allowing detection of the key.
 250:Lab7_Ex3_G09.c **** */
 251:Lab7_Ex3_G09.c **** void keypad_init(void) 
 252:Lab7_Ex3_G09.c **** {
 136               		.loc 1 252 0
 137               		.cfi_startproc
 138               	/* prologue: function */
 139               	/* frame size = 0 */
 140               	/* stack size = 0 */
 141               	.L__stack_usage = 0
 253:Lab7_Ex3_G09.c ****     // Set respective row ports as outputs
 254:Lab7_Ex3_G09.c ****     ROW1_DDR |= (1 << ROW1_PIN);
 142               		.loc 1 254 0
 143 0056 579A      		sbi 0xa,7
 255:Lab7_Ex3_G09.c ****     ROW2_DDR |= (1 << ROW2_PIN);
 144               		.loc 1 255 0
 145 0058 569A      		sbi 0xa,6
 256:Lab7_Ex3_G09.c ****     ROW3_DDR |= (1 << ROW3_PIN);
 146               		.loc 1 256 0
 147 005a 209A      		sbi 0x4,0
 257:Lab7_Ex3_G09.c ****     ROW4_DDR |= (1 << ROW4_PIN);
 148               		.loc 1 257 0
 149 005c 219A      		sbi 0x4,1
 258:Lab7_Ex3_G09.c **** 
 259:Lab7_Ex3_G09.c ****     // Set columns as inputs
 260:Lab7_Ex3_G09.c ****     DDRB &= ~((1 << COL1_PIN) | (1 << COL2_PIN) | (1 << COL3_PIN) | (1 << COL4_PIN));
 150               		.loc 1 260 0
 151 005e 84B1      		in r24,0x4
 152 0060 837C      		andi r24,lo8(-61)
 153 0062 84B9      		out 0x4,r24
 261:Lab7_Ex3_G09.c **** 
 262:Lab7_Ex3_G09.c ****     // Enable pull-up resistors on column pins
 263:Lab7_Ex3_G09.c ****     PORTB |= (1 << COL1_PIN) | (1 << COL2_PIN) | (1 << COL3_PIN) | (1 << COL4_PIN);
 154               		.loc 1 263 0
 155 0064 85B1      		in r24,0x5
 156 0066 8C63      		ori r24,lo8(60)
 157 0068 85B9      		out 0x5,r24
 158               	/* epilogue start */
 264:Lab7_Ex3_G09.c **** }
 159               		.loc 1 264 0
 160 006a 0895      		ret
 161               		.cfi_endproc
 162               	.LFE10:
 164               		.section	.rodata
 165               	.LC0:
 166 0000 2B00      		.word	43
 167 0002 2B00      		.word	43
 168 0004 2500      		.word	37
 169 0006 2500      		.word	37
 170               	.LC1:
 171 0008 06        		.byte	6
 172 0009 07        		.byte	7
 173 000a 00        		.byte	0
 174 000b 01        		.byte	1
 175               		.text
 176               	.global	keypad_getkey
 178               	keypad_getkey:
 179               	.LFB11:
 265:Lab7_Ex3_G09.c **** 
 266:Lab7_Ex3_G09.c **** /*
 267:Lab7_Ex3_G09.c **** Now we need to scan the keypad for key presses.
 268:Lab7_Ex3_G09.c ****     The function keypad_getkey() will iterate through each row, setting it low one at a time,
 269:Lab7_Ex3_G09.c ****     and checking the state of the columns. If a column reads low, it means a key in that row
 270:Lab7_Ex3_G09.c ****     and column is pressed, and we return the corresponding character from the keymap.
 271:Lab7_Ex3_G09.c **** */
 272:Lab7_Ex3_G09.c **** 
 273:Lab7_Ex3_G09.c **** char keypad_getkey(void) 
 274:Lab7_Ex3_G09.c **** {
 180               		.loc 1 274 0
 181               		.cfi_startproc
 182 006c CF92      		push r12
 183               	.LCFI0:
 184               		.cfi_def_cfa_offset 3
 185               		.cfi_offset 12, -2
 186 006e DF92      		push r13
 187               	.LCFI1:
 188               		.cfi_def_cfa_offset 4
 189               		.cfi_offset 13, -3
 190 0070 EF92      		push r14
 191               	.LCFI2:
 192               		.cfi_def_cfa_offset 5
 193               		.cfi_offset 14, -4
 194 0072 FF92      		push r15
 195               	.LCFI3:
 196               		.cfi_def_cfa_offset 6
 197               		.cfi_offset 15, -5
 198 0074 0F93      		push r16
 199               	.LCFI4:
 200               		.cfi_def_cfa_offset 7
 201               		.cfi_offset 16, -6
 202 0076 1F93      		push r17
 203               	.LCFI5:
 204               		.cfi_def_cfa_offset 8
 205               		.cfi_offset 17, -7
 206 0078 CF93      		push r28
 207               	.LCFI6:
 208               		.cfi_def_cfa_offset 9
 209               		.cfi_offset 28, -8
 210 007a DF93      		push r29
 211               	.LCFI7:
 212               		.cfi_def_cfa_offset 10
 213               		.cfi_offset 29, -9
 214 007c CDB7      		in r28,__SP_L__
 215 007e DEB7      		in r29,__SP_H__
 216               	.LCFI8:
 217               		.cfi_def_cfa_register 28
 218 0080 2C97      		sbiw r28,12
 219               	.LCFI9:
 220               		.cfi_def_cfa_offset 22
 221 0082 0FB6      		in __tmp_reg__,__SREG__
 222 0084 F894      		cli
 223 0086 DEBF      		out __SP_H__,r29
 224 0088 0FBE      		out __SREG__,__tmp_reg__
 225 008a CDBF      		out __SP_L__,r28
 226               	/* prologue: function */
 227               	/* frame size = 12 */
 228               	/* stack size = 20 */
 229               	.L__stack_usage = 20
 275:Lab7_Ex3_G09.c ****     /*
 276:Lab7_Ex3_G09.c **** 
 277:Lab7_Ex3_G09.c ****     Here, we create an array of pointers to the row ports and an array of row pin numbers.
 278:Lab7_Ex3_G09.c ****     This allows us to easily iterate through the rows and set them low one at a time.
 279:Lab7_Ex3_G09.c ****     The row_ports array holds the addresses of the PORT registers for each row,
 280:Lab7_Ex3_G09.c ****     and the row_pins array holds the pin numbers for each row.  
 281:Lab7_Ex3_G09.c **** 
 282:Lab7_Ex3_G09.c ****     */
 283:Lab7_Ex3_G09.c **** 
 284:Lab7_Ex3_G09.c ****     volatile uint8_t* row_ports[4] = {&ROW2_PORT, &ROW1_PORT, &ROW3_PORT, &ROW4_PORT};
 230               		.loc 1 284 0
 231 008c 88E0      		ldi r24,lo8(8)
 232 008e E0E0      		ldi r30,lo8(.LC0)
 233 0090 F0E0      		ldi r31,hi8(.LC0)
 234 0092 DE01      		movw r26,r28
 235 0094 1196      		adiw r26,1
 236               		0:
 237 0096 0190      		ld r0,Z+
 238 0098 0D92      		st X+,r0
 239 009a 8A95      		dec r24
 240 009c 01F4      		brne 0b
 285:Lab7_Ex3_G09.c ****     uint8_t row_pins[4] = {ROW2_PIN, ROW1_PIN, ROW3_PIN, ROW4_PIN};
 241               		.loc 1 285 0
 242 009e 8091 0000 		lds r24,.LC1
 243 00a2 9091 0000 		lds r25,.LC1+1
 244 00a6 A091 0000 		lds r26,.LC1+2
 245 00aa B091 0000 		lds r27,.LC1+3
 246 00ae 8987      		std Y+9,r24
 247 00b0 9A87      		std Y+10,r25
 248 00b2 AB87      		std Y+11,r26
 249 00b4 BC87      		std Y+12,r27
 250               	.LVL11:
 251 00b6 AE01      		movw r20,r28
 252 00b8 4F5F      		subi r20,-1
 253 00ba 5F4F      		sbci r21,-1
 254 00bc 6A01      		movw r12,r20
 255 00be DE01      		movw r26,r28
 256 00c0 1996      		adiw r26,9
 257 00c2 90E0      		ldi r25,0
 258 00c4 80E0      		ldi r24,0
 259               	.LBB23:
 260               	.LBB24:
 286:Lab7_Ex3_G09.c **** 
 287:Lab7_Ex3_G09.c **** 
 288:Lab7_Ex3_G09.c ****     // Iterate through each row
 289:Lab7_Ex3_G09.c ****     // We will set each row low one at a time and check the columns for a key
 290:Lab7_Ex3_G09.c ****     // If a key is pressed, we will return the corresponding character from the keymap
 291:Lab7_Ex3_G09.c ****     // We will use a delay to allow the row to stabilize before reading the columns
 292:Lab7_Ex3_G09.c **** 
 293:Lab7_Ex3_G09.c ****     for (uint8_t row = 0; row < 4; row++) 
 294:Lab7_Ex3_G09.c ****     {
 295:Lab7_Ex3_G09.c ****         // Set all rows HIGH first
 296:Lab7_Ex3_G09.c ****         ROW1_PORT |= (1 << ROW1_PIN);
 297:Lab7_Ex3_G09.c ****         ROW2_PORT |= (1 << ROW2_PIN);
 298:Lab7_Ex3_G09.c ****         ROW3_PORT |= (1 << ROW3_PIN);
 299:Lab7_Ex3_G09.c ****         ROW4_PORT |= (1 << ROW4_PIN);
 300:Lab7_Ex3_G09.c **** 
 301:Lab7_Ex3_G09.c ****         // Set current row LOW
 302:Lab7_Ex3_G09.c ****         *(row_ports[row]) &= ~(1 << row_pins[row]);
 261               		.loc 1 302 0
 262 00c6 61E0      		ldi r22,lo8(1)
 263 00c8 70E0      		ldi r23,0
 264               	.LVL12:
 265               	.L16:
 296:Lab7_Ex3_G09.c ****         ROW2_PORT |= (1 << ROW2_PIN);
 266               		.loc 1 296 0
 267 00ca 5F9A      		sbi 0xb,7
 297:Lab7_Ex3_G09.c ****         ROW3_PORT |= (1 << ROW3_PIN);
 268               		.loc 1 297 0
 269 00cc 5E9A      		sbi 0xb,6
 298:Lab7_Ex3_G09.c ****         ROW4_PORT |= (1 << ROW4_PIN);
 270               		.loc 1 298 0
 271 00ce 289A      		sbi 0x5,0
 299:Lab7_Ex3_G09.c **** 
 272               		.loc 1 299 0
 273 00d0 299A      		sbi 0x5,1
 274               		.loc 1 302 0
 275 00d2 F601      		movw r30,r12
 276 00d4 4191      		ld r20,Z+
 277 00d6 5191      		ld r21,Z+
 278 00d8 6F01      		movw r12,r30
 279 00da FA01      		movw r30,r20
 280 00dc 1081      		ld r17,Z
 281 00de 2D91      		ld r18,X+
 282 00e0 FB01      		movw r30,r22
 283 00e2 00C0      		rjmp 2f
 284               		1:
 285 00e4 EE0F      		lsl r30
 286 00e6 FF1F      		rol r31
 287               		2:
 288 00e8 2A95      		dec r18
 289 00ea 02F4      		brpl 1b
 290 00ec 9F01      		movw r18,r30
 291 00ee 2095      		com r18
 292 00f0 2123      		and r18,r17
 293 00f2 FA01      		movw r30,r20
 294 00f4 2083      		st Z,r18
 295               	.LVL13:
 296               	.LBB25:
 297               	.LBB26:
 298               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 299               		.loc 2 276 0
 300 00f6 FAE1      		ldi r31,lo8(26)
 301 00f8 FA95      	1:	dec r31
 302 00fa 01F4      		brne 1b
 303 00fc 00C0      		rjmp .
 304               	.LVL14:
 305               	.LBE26:
 306               	.LBE25:
 303:Lab7_Ex3_G09.c ****         // Delay to allow the row to stabilize
 304:Lab7_Ex3_G09.c ****         _delay_us(5);
 305:Lab7_Ex3_G09.c **** 
 306:Lab7_Ex3_G09.c ****         // Read columns
 307:Lab7_Ex3_G09.c ****         // col_val will hold the state of the columns
 308:Lab7_Ex3_G09.c ****         // We will read the state of the columns using PINB register
 309:Lab7_Ex3_G09.c ****         // Using mask 0b00111100 to read only the relevant bits (PB2-PB5)
 310:Lab7_Ex3_G09.c ****         uint8_t col_val = PINB & 0b00111100; // PB2-PB5
 307               		.loc 1 310 0
 308 00fe 43B1      		in r20,0x3
 309               		.loc 1 310 0
 310 0100 4C73      		andi r20,lo8(60)
 311               	.LVL15:
 312 0102 30E0      		ldi r19,0
 313 0104 20E0      		ldi r18,0
 314               	.LBB27:
 311:Lab7_Ex3_G09.c **** 
 312:Lab7_Ex3_G09.c ****         // Now we write a loop to check each column
 313:Lab7_Ex3_G09.c ****         // If a column reads low, it means a key in that row and column is pressed
 314:Lab7_Ex3_G09.c ****         for (uint8_t col = 0; col < 4; col++) 
 315:Lab7_Ex3_G09.c ****         {   
 316:Lab7_Ex3_G09.c ****             // Check if the column is low
 317:Lab7_Ex3_G09.c ****             if (!(col_val & (1 << (COL1_PIN + col)))) 
 315               		.loc 1 317 0
 316 0106 50E0      		ldi r21,0
 317               	.LVL16:
 318               	.L15:
 319 0108 8901      		movw r16,r18
 320 010a 0E5F      		subi r16,-2
 321 010c 1F4F      		sbci r17,-1
 322 010e 7A01      		movw r14,r20
 323 0110 002E      		mov r0,r16
 324 0112 00C0      		rjmp 2f
 325               		1:
 326 0114 F594      		asr r15
 327 0116 E794      		ror r14
 328               		2:
 329 0118 0A94      		dec r0
 330 011a 02F4      		brpl 1b
 331 011c E0FC      		sbrc r14,0
 332 011e 00C0      		rjmp .L12
 333               	.LVL17:
 334               	.LBB28:
 335               	.LBB29:
 187:/usr/lib/avr/include/util/delay.h **** 
 336               		.loc 2 187 0
 337 0120 4FEF      		ldi r20,lo8(63999)
 338 0122 59EF      		ldi r21,hi8(63999)
 339 0124 60E0      		ldi r22,hlo8(63999)
 340 0126 4150      	1:	subi r20,1
 341 0128 5040      		sbci r21,0
 342 012a 6040      		sbci r22,0
 343 012c 01F4      		brne 1b
 344               	.LVL18:
 345 012e 00C0      		rjmp .
 346 0130 0000      		nop
 347 0132 61E0      		ldi r22,lo8(1)
 348 0134 70E0      		ldi r23,0
 349 0136 00C0      		rjmp 2f
 350               		1:
 351 0138 660F      		lsl r22
 352 013a 771F      		rol r23
 353               		2:
 354 013c 0A95      		dec r16
 355 013e 02F4      		brpl 1b
 356               	.L13:
 357               	.LBE29:
 358               	.LBE28:
 318:Lab7_Ex3_G09.c ****             {   
 319:Lab7_Ex3_G09.c ****                 _delay_ms(20); // Debounce after press
 320:Lab7_Ex3_G09.c **** 
 321:Lab7_Ex3_G09.c ****                 // Wait for key release (simple debounce)
 322:Lab7_Ex3_G09.c ****                 while (!(PINB & (1 << (COL1_PIN + col))));
 359               		.loc 1 322 0 discriminator 1
 360 0140 43B1      		in r20,0x3
 361 0142 50E0      		ldi r21,0
 362               		.loc 1 322 0 discriminator 1
 363 0144 4623      		and r20,r22
 364 0146 5723      		and r21,r23
 365 0148 452B      		or r20,r21
 366 014a 01F0      		breq .L13
 367               	.LVL19:
 368               	.LBB30:
 369               	.LBB31:
 187:/usr/lib/avr/include/util/delay.h **** 
 370               		.loc 2 187 0
 371 014c EFEF      		ldi r30,lo8(159999)
 372 014e F0E7      		ldi r31,hi8(159999)
 373 0150 42E0      		ldi r20,hlo8(159999)
 374 0152 E150      	1:	subi r30,1
 375 0154 F040      		sbci r31,0
 376 0156 4040      		sbci r20,0
 377 0158 01F4      		brne 1b
 378 015a 00C0      		rjmp .
 379 015c 0000      		nop
 380               	.LVL20:
 381               	.LBE31:
 382               	.LBE30:
 323:Lab7_Ex3_G09.c **** 
 324:Lab7_Ex3_G09.c ****                 _delay_ms(50); // Debounce delay after release
 325:Lab7_Ex3_G09.c **** 
 326:Lab7_Ex3_G09.c ****                 // Return the corresponding key from the keymap
 327:Lab7_Ex3_G09.c ****                 // The row and column indices are used to access the keymap
 328:Lab7_Ex3_G09.c ****                 return keymap[row][col];
 383               		.loc 1 328 0
 384 015e 880F      		lsl r24
 385 0160 991F      		rol r25
 386 0162 880F      		lsl r24
 387 0164 991F      		rol r25
 388               	.LVL21:
 389 0166 8050      		subi r24,lo8(-(keymap))
 390 0168 9040      		sbci r25,hi8(-(keymap))
 391 016a 280F      		add r18,r24
 392 016c 391F      		adc r19,r25
 393               	.LVL22:
 394 016e F901      		movw r30,r18
 395 0170 8081      		ld r24,Z
 396               	.LVL23:
 397               	.L11:
 398               	/* epilogue start */
 399               	.LBE27:
 400               	.LBE24:
 401               	.LBE23:
 329:Lab7_Ex3_G09.c ****             }
 330:Lab7_Ex3_G09.c ****         }
 331:Lab7_Ex3_G09.c ****     } 
 332:Lab7_Ex3_G09.c ****     return 0;
 333:Lab7_Ex3_G09.c **** }
 402               		.loc 1 333 0
 403 0172 2C96      		adiw r28,12
 404 0174 0FB6      		in __tmp_reg__,__SREG__
 405 0176 F894      		cli
 406 0178 DEBF      		out __SP_H__,r29
 407 017a 0FBE      		out __SREG__,__tmp_reg__
 408 017c CDBF      		out __SP_L__,r28
 409 017e DF91      		pop r29
 410 0180 CF91      		pop r28
 411 0182 1F91      		pop r17
 412 0184 0F91      		pop r16
 413 0186 FF90      		pop r15
 414 0188 EF90      		pop r14
 415 018a DF90      		pop r13
 416 018c CF90      		pop r12
 417 018e 0895      		ret
 418               	.LVL24:
 419               	.L12:
 420 0190 2F5F      		subi r18,-1
 421 0192 3F4F      		sbci r19,-1
 422               	.LVL25:
 423               	.LBB34:
 424               	.LBB33:
 425               	.LBB32:
 314:Lab7_Ex3_G09.c ****         {   
 426               		.loc 1 314 0 discriminator 2
 427 0194 2430      		cpi r18,4
 428 0196 3105      		cpc r19,__zero_reg__
 429 0198 01F0      		breq .+2
 430 019a 00C0      		rjmp .L15
 431               	.LVL26:
 432 019c 0196      		adiw r24,1
 433               	.LVL27:
 434               	.LBE32:
 435               	.LBE33:
 293:Lab7_Ex3_G09.c ****     {
 436               		.loc 1 293 0 discriminator 2
 437 019e 8430      		cpi r24,4
 438 01a0 9105      		cpc r25,__zero_reg__
 439 01a2 01F0      		breq .+2
 440 01a4 00C0      		rjmp .L16
 441               	.LBE34:
 332:Lab7_Ex3_G09.c **** }
 442               		.loc 1 332 0
 443 01a6 80E0      		ldi r24,0
 444               	.LVL28:
 445 01a8 00C0      		rjmp .L11
 446               		.cfi_endproc
 447               	.LFE11:
 449               		.section	.rodata.str1.1,"aMS",@progbits,1
 450               	.LC2:
 451 0000 413A 456E 		.string	"A:Encrypt B:Key"
 451      6372 7970 
 451      7420 423A 
 451      4B65 7900 
 452               	.LC3:
 453 0010 4375 7272 		.string	"Current Key: "
 453      656E 7420 
 453      4B65 793A 
 453      2000 
 454               	.LC4:
 455 001e 4E65 7720 		.string	"New Key (0-9):"
 455      4B65 7920 
 455      2830 2D39 
 455      293A 00
 456               	.LC5:
 457 002d 4B65 7920 		.string	"Key Updated!"
 457      5570 6461 
 457      7465 6421 
 457      00
 458               	.LC6:
 459 003a 456E 7465 		.string	"Enter Text:"
 459      7220 5465 
 459      7874 3A00 
 460               	.LC7:
 461 0046 456E 6372 		.string	"Encrypted:"
 461      7970 7465 
 461      643A 00
 462               		.section	.text.startup,"ax",@progbits
 463               	.global	main
 465               	main:
 466               	.LFB12:
 334:Lab7_Ex3_G09.c **** 
 335:Lab7_Ex3_G09.c **** /*
 336:Lab7_Ex3_G09.c **** *******************************************************************************
 337:Lab7_Ex3_G09.c **** *******************************************************************************
 338:Lab7_Ex3_G09.c ****     MAIN FUNCTION
 339:Lab7_Ex3_G09.c **** *******************************************************************************
 340:Lab7_Ex3_G09.c **** *******************************************************************************
 341:Lab7_Ex3_G09.c **** */
 342:Lab7_Ex3_G09.c **** 
 343:Lab7_Ex3_G09.c **** /*
 344:Lab7_Ex3_G09.c **** The main function should:
 345:Lab7_Ex3_G09.c ****     - Ask whether we want to encrypt or change the secret key.
 346:Lab7_Ex3_G09.c ****     - Change Key: 
 347:Lab7_Ex3_G09.c ****         - It should prompt for a new key
 348:Lab7_Ex3_G09.c ****         - Using the Keypad
 349:Lab7_Ex3_G09.c ****         - The new key should be stored in EEPROM
 350:Lab7_Ex3_G09.c ****     - Encrypt Text:
 351:Lab7_Ex3_G09.c ****         - It should prompt for the plain text
 352:Lab7_Ex3_G09.c ****         - Using the Keypad
 353:Lab7_Ex3_G09.c ****         - The entered text should be encrypted using the secret key
 354:Lab7_Ex3_G09.c ****         - The encrypted text should be displayed on the LCD
 355:Lab7_Ex3_G09.c **** */
 356:Lab7_Ex3_G09.c **** 
 357:Lab7_Ex3_G09.c **** int main(void)
 358:Lab7_Ex3_G09.c **** {
 467               		.loc 1 358 0
 468               		.cfi_startproc
 469 0000 CF93      		push r28
 470               	.LCFI10:
 471               		.cfi_def_cfa_offset 3
 472               		.cfi_offset 28, -2
 473 0002 DF93      		push r29
 474               	.LCFI11:
 475               		.cfi_def_cfa_offset 4
 476               		.cfi_offset 29, -3
 477 0004 CDB7      		in r28,__SP_L__
 478 0006 DEB7      		in r29,__SP_H__
 479               	.LCFI12:
 480               		.cfi_def_cfa_register 28
 481 0008 6697      		sbiw r28,22
 482               	.LCFI13:
 483               		.cfi_def_cfa_offset 26
 484 000a 0FB6      		in __tmp_reg__,__SREG__
 485 000c F894      		cli
 486 000e DEBF      		out __SP_H__,r29
 487 0010 0FBE      		out __SREG__,__tmp_reg__
 488 0012 CDBF      		out __SP_L__,r28
 489               	/* prologue: function */
 490               	/* frame size = 22 */
 491               	/* stack size = 24 */
 492               	.L__stack_usage = 24
 359:Lab7_Ex3_G09.c ****     // Initialize the LCD
 360:Lab7_Ex3_G09.c ****     lcd_init(LCD_DISP_ON);
 493               		.loc 1 360 0
 494 0014 8CE0      		ldi r24,lo8(12)
 495 0016 0E94 0000 		call lcd_init
 496               	.LVL29:
 361:Lab7_Ex3_G09.c **** 
 362:Lab7_Ex3_G09.c ****     // Initialize the keypad
 363:Lab7_Ex3_G09.c ****     keypad_init();
 497               		.loc 1 363 0
 498 001a 0E94 0000 		call keypad_init
 499               	.LVL30:
 364:Lab7_Ex3_G09.c **** 
 365:Lab7_Ex3_G09.c **** 
 366:Lab7_Ex3_G09.c ****     // Variable to hold the secret key
 367:Lab7_Ex3_G09.c ****     uint8_t secret_key = 3; // Default key for Caesar cipher
 368:Lab7_Ex3_G09.c **** 
 369:Lab7_Ex3_G09.c ****     // Variable to hold the input text
 370:Lab7_Ex3_G09.c ****     char input_text[11] = {0}; // 10 characters + null terminator
 500               		.loc 1 370 0
 501 001e 8BE0      		ldi r24,lo8(11)
 502 0020 8E01      		movw r16,r28
 503 0022 045F      		subi r16,-12
 504 0024 1F4F      		sbci r17,-1
 505 0026 F801      		movw r30,r16
 506 0028 282F      		mov r18,r24
 507               		0:
 508 002a 1192      		st Z+,__zero_reg__
 509 002c 2A95      		dec r18
 510 002e 01F4      		brne 0b
 371:Lab7_Ex3_G09.c ****     char encrypted_text[11] = {0}; // 10 characters + null terminator
 511               		.loc 1 371 0
 512 0030 FE01      		movw r30,r28
 513 0032 3196      		adiw r30,1
 514 0034 6F01      		movw r12,r30
 515               		0:
 516 0036 1192      		st Z+,__zero_reg__
 517 0038 8A95      		dec r24
 518 003a 01F4      		brne 0b
 372:Lab7_Ex3_G09.c **** 
 373:Lab7_Ex3_G09.c ****     // Store the initial secret key in EEPROM
 374:Lab7_Ex3_G09.c ****     // At address 0
 375:Lab7_Ex3_G09.c ****     EEPROMwrite(0, secret_key);
 519               		.loc 1 375 0
 520 003c 63E0      		ldi r22,lo8(3)
 521 003e 90E0      		ldi r25,0
 522 0040 80E0      		ldi r24,0
 523 0042 0E94 0000 		call EEPROMwrite
 524               	.LVL31:
 525               	.L31:
 376:Lab7_Ex3_G09.c **** 
 377:Lab7_Ex3_G09.c ****     // Variable to hold the choice
 378:Lab7_Ex3_G09.c ****     char choice;
 379:Lab7_Ex3_G09.c **** 
 380:Lab7_Ex3_G09.c ****     // Main loop
 381:Lab7_Ex3_G09.c ****     while (1)
 382:Lab7_Ex3_G09.c ****     {
 383:Lab7_Ex3_G09.c ****         // Read the secret key from EEPROM
 384:Lab7_Ex3_G09.c ****         secret_key = EEPROMread(0);
 526               		.loc 1 384 0
 527 0046 90E0      		ldi r25,0
 528 0048 80E0      		ldi r24,0
 529 004a 0E94 0000 		call EEPROMread
 530               	.LVL32:
 531 004e E82E      		mov r14,r24
 532               	.LVL33:
 385:Lab7_Ex3_G09.c **** 
 386:Lab7_Ex3_G09.c ****         // Display menu on LCD
 387:Lab7_Ex3_G09.c ****         lcd_clrscr();
 533               		.loc 1 387 0
 534 0050 0E94 0000 		call lcd_clrscr
 535               	.LVL34:
 388:Lab7_Ex3_G09.c ****         lcd_gotoxy(0, 0);
 536               		.loc 1 388 0
 537 0054 60E0      		ldi r22,0
 538 0056 80E0      		ldi r24,0
 539 0058 0E94 0000 		call lcd_gotoxy
 540               	.LVL35:
 389:Lab7_Ex3_G09.c ****         lcd_puts("A:Encrypt B:Key");
 541               		.loc 1 389 0
 542 005c 80E0      		ldi r24,lo8(.LC2)
 543 005e 90E0      		ldi r25,hi8(.LC2)
 544 0060 0E94 0000 		call lcd_puts
 545               	.LVL36:
 390:Lab7_Ex3_G09.c ****         lcd_gotoxy(0, 1);
 546               		.loc 1 390 0
 547 0064 61E0      		ldi r22,lo8(1)
 548 0066 80E0      		ldi r24,0
 549 0068 0E94 0000 		call lcd_gotoxy
 550               	.LVL37:
 391:Lab7_Ex3_G09.c ****         lcd_puts("Current Key: ");
 551               		.loc 1 391 0
 552 006c 80E0      		ldi r24,lo8(.LC3)
 553 006e 90E0      		ldi r25,hi8(.LC3)
 554 0070 0E94 0000 		call lcd_puts
 555               	.LVL38:
 392:Lab7_Ex3_G09.c ****         lcd_putc(secret_key + '0');
 556               		.loc 1 392 0
 557 0074 80E3      		ldi r24,lo8(48)
 558 0076 8E0D      		add r24,r14
 559 0078 0E94 0000 		call lcd_putc
 560               	.LVL39:
 561               	.L22:
 393:Lab7_Ex3_G09.c **** 
 394:Lab7_Ex3_G09.c ****         // Wait for user choice
 395:Lab7_Ex3_G09.c ****         do 
 396:Lab7_Ex3_G09.c ****         {
 397:Lab7_Ex3_G09.c ****             choice = keypad_getkey();
 562               		.loc 1 397 0 discriminator 1
 563 007c 0E94 0000 		call keypad_getkey
 564               	.LVL40:
 398:Lab7_Ex3_G09.c ****         } 
 399:Lab7_Ex3_G09.c ****         while (choice != 'A' && choice != 'B');
 565               		.loc 1 399 0 discriminator 1
 566 0080 9FEB      		ldi r25,lo8(-65)
 567 0082 980F      		add r25,r24
 568 0084 9230      		cpi r25,lo8(2)
 569 0086 00F4      		brsh .L22
 400:Lab7_Ex3_G09.c **** 
 401:Lab7_Ex3_G09.c ****         if (choice == 'B') 
 570               		.loc 1 401 0
 571 0088 8234      		cpi r24,lo8(66)
 572 008a 01F4      		brne .L23
 573               	.LBB35:
 402:Lab7_Ex3_G09.c ****         {
 403:Lab7_Ex3_G09.c ****             // Change secret key
 404:Lab7_Ex3_G09.c ****             lcd_clrscr();
 574               		.loc 1 404 0
 575 008c 0E94 0000 		call lcd_clrscr
 576               	.LVL41:
 405:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 0);
 577               		.loc 1 405 0
 578 0090 60E0      		ldi r22,0
 579 0092 80E0      		ldi r24,0
 580 0094 0E94 0000 		call lcd_gotoxy
 581               	.LVL42:
 406:Lab7_Ex3_G09.c ****             lcd_puts("New Key (0-9):");
 582               		.loc 1 406 0
 583 0098 80E0      		ldi r24,lo8(.LC4)
 584 009a 90E0      		ldi r25,hi8(.LC4)
 585 009c 0E94 0000 		call lcd_puts
 586               	.LVL43:
 587               	.L24:
 407:Lab7_Ex3_G09.c **** 
 408:Lab7_Ex3_G09.c ****             char key_char = 0;
 409:Lab7_Ex3_G09.c **** 
 410:Lab7_Ex3_G09.c ****             do 
 411:Lab7_Ex3_G09.c ****             {
 412:Lab7_Ex3_G09.c ****                 key_char = keypad_getkey();
 588               		.loc 1 412 0 discriminator 1
 589 00a0 0E94 0000 		call keypad_getkey
 590               	.LVL44:
 413:Lab7_Ex3_G09.c ****             } 
 414:Lab7_Ex3_G09.c ****             while (key_char < '0' || key_char > '9');
 591               		.loc 1 414 0 discriminator 1
 592 00a4 60ED      		ldi r22,lo8(-48)
 593 00a6 680F      		add r22,r24
 594 00a8 6A30      		cpi r22,lo8(10)
 595 00aa 00F4      		brsh .L24
 596               	.LVL45:
 415:Lab7_Ex3_G09.c **** 
 416:Lab7_Ex3_G09.c ****             secret_key = key_char - '0';
 417:Lab7_Ex3_G09.c **** 
 418:Lab7_Ex3_G09.c ****             EEPROMwrite(0, secret_key);
 597               		.loc 1 418 0
 598 00ac 90E0      		ldi r25,0
 599 00ae 80E0      		ldi r24,0
 600               	.LVL46:
 601 00b0 0E94 0000 		call EEPROMwrite
 602               	.LVL47:
 419:Lab7_Ex3_G09.c ****             lcd_clrscr();
 603               		.loc 1 419 0
 604 00b4 0E94 0000 		call lcd_clrscr
 605               	.LVL48:
 420:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 0);
 606               		.loc 1 420 0
 607 00b8 60E0      		ldi r22,0
 608 00ba 80E0      		ldi r24,0
 609 00bc 0E94 0000 		call lcd_gotoxy
 610               	.LVL49:
 421:Lab7_Ex3_G09.c ****             lcd_puts("Key Updated!");
 611               		.loc 1 421 0
 612 00c0 80E0      		ldi r24,lo8(.LC5)
 613 00c2 90E0      		ldi r25,hi8(.LC5)
 614 00c4 0E94 0000 		call lcd_puts
 615               	.LVL50:
 616               	.LBB36:
 617               	.LBB37:
 187:/usr/lib/avr/include/util/delay.h **** 
 618               		.loc 2 187 0
 619 00c8 FFEF      		ldi r31,lo8(3199999)
 620 00ca 23ED      		ldi r18,hi8(3199999)
 621 00cc 30E3      		ldi r19,hlo8(3199999)
 622 00ce F150      	1:	subi r31,1
 623 00d0 2040      		sbci r18,0
 624 00d2 3040      		sbci r19,0
 625 00d4 01F4      		brne 1b
 626               	.LVL51:
 627               	.L42:
 628               	.LBE37:
 629               	.LBE36:
 630               	.LBE35:
 631               	.LBB38:
 632               	.LBB39:
 633               	.LBB40:
 634 00d6 00C0      		rjmp .
 635 00d8 0000      		nop
 636               	.LBE40:
 637               	.LBE39:
 638               	.LBE38:
 422:Lab7_Ex3_G09.c ****             _delay_ms(1000);
 423:Lab7_Ex3_G09.c **** 
 424:Lab7_Ex3_G09.c ****         } 
 425:Lab7_Ex3_G09.c ****         
 426:Lab7_Ex3_G09.c ****         else if (choice == 'A') 
 427:Lab7_Ex3_G09.c ****         
 428:Lab7_Ex3_G09.c ****         {
 429:Lab7_Ex3_G09.c ****             // Wait for key release to avoid double reading the menu key
 430:Lab7_Ex3_G09.c ****             while (keypad_getkey());
 431:Lab7_Ex3_G09.c **** 
 432:Lab7_Ex3_G09.c ****             // Encrypt text
 433:Lab7_Ex3_G09.c ****             lcd_clrscr();
 434:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 0);
 435:Lab7_Ex3_G09.c ****             lcd_puts("Enter Text:");
 436:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 1);
 437:Lab7_Ex3_G09.c **** 
 438:Lab7_Ex3_G09.c ****             // Input text from keypad
 439:Lab7_Ex3_G09.c ****             // We need the variable index(idx) to keep track of the number of characters entered
 440:Lab7_Ex3_G09.c ****             uint8_t idx = 0;
 441:Lab7_Ex3_G09.c ****             while (idx < 10) 
 442:Lab7_Ex3_G09.c ****             {   
 443:Lab7_Ex3_G09.c ****                 // Initialize a character variable to hold the key pressed
 444:Lab7_Ex3_G09.c ****                 char ch = 0;
 445:Lab7_Ex3_G09.c **** 
 446:Lab7_Ex3_G09.c ****                 // Wait for a key press
 447:Lab7_Ex3_G09.c ****                 while (!(ch = keypad_getkey()));
 448:Lab7_Ex3_G09.c **** 
 449:Lab7_Ex3_G09.c ****                 // If the key is '#', break the loop to finish early
 450:Lab7_Ex3_G09.c ****                 if (ch == '#') break;
 451:Lab7_Ex3_G09.c **** 
 452:Lab7_Ex3_G09.c ****                 // Character is added to input_text
 453:Lab7_Ex3_G09.c ****                 input_text[idx] = ch;
 454:Lab7_Ex3_G09.c **** 
 455:Lab7_Ex3_G09.c ****                 // Display the character on the LCD
 456:Lab7_Ex3_G09.c ****                 lcd_putc(ch);
 457:Lab7_Ex3_G09.c **** 
 458:Lab7_Ex3_G09.c ****                 // Increment the index
 459:Lab7_Ex3_G09.c ****                 idx++;
 460:Lab7_Ex3_G09.c ****             }
 461:Lab7_Ex3_G09.c **** 
 462:Lab7_Ex3_G09.c ****             // Null-terminate the input text
 463:Lab7_Ex3_G09.c ****             input_text[idx] = '\0';
 464:Lab7_Ex3_G09.c **** 
 465:Lab7_Ex3_G09.c ****             // Encrypt the text
 466:Lab7_Ex3_G09.c ****             for (uint8_t i = 0; i < idx; i++) 
 467:Lab7_Ex3_G09.c ****             {   
 468:Lab7_Ex3_G09.c ****                 // Use the caesar_cipher function to encrypt each character
 469:Lab7_Ex3_G09.c ****                 encrypted_text[i] = caesar_cipher(input_text[i], secret_key);
 470:Lab7_Ex3_G09.c ****             }
 471:Lab7_Ex3_G09.c **** 
 472:Lab7_Ex3_G09.c ****             // Again, null-terminate the encrypted text
 473:Lab7_Ex3_G09.c ****             encrypted_text[idx] = '\0';
 474:Lab7_Ex3_G09.c **** 
 475:Lab7_Ex3_G09.c ****             // Display encrypted text
 476:Lab7_Ex3_G09.c ****             lcd_clrscr();
 477:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 0);
 478:Lab7_Ex3_G09.c ****             lcd_puts("Encrypted:");
 479:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 1);
 480:Lab7_Ex3_G09.c ****             lcd_puts(encrypted_text);
 481:Lab7_Ex3_G09.c ****             _delay_ms(3000);
 482:Lab7_Ex3_G09.c ****         }
 483:Lab7_Ex3_G09.c **** 
 484:Lab7_Ex3_G09.c ****         // Clear LCD for next operation
 485:Lab7_Ex3_G09.c ****         lcd_clrscr();
 639               		.loc 1 485 0
 640 00da 0E94 0000 		call lcd_clrscr
 641               	.LVL52:
 384:Lab7_Ex3_G09.c **** 
 642               		.loc 1 384 0
 643 00de 00C0      		rjmp .L31
 644               	.LVL53:
 645               	.L23:
 646               	.LBB46:
 430:Lab7_Ex3_G09.c **** 
 647               		.loc 1 430 0 discriminator 1
 648 00e0 0E94 0000 		call keypad_getkey
 649               	.LVL54:
 650 00e4 8111      		cpse r24,__zero_reg__
 651 00e6 00C0      		rjmp .L23
 433:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 0);
 652               		.loc 1 433 0
 653 00e8 0E94 0000 		call lcd_clrscr
 654               	.LVL55:
 434:Lab7_Ex3_G09.c ****             lcd_puts("Enter Text:");
 655               		.loc 1 434 0
 656 00ec 60E0      		ldi r22,0
 657 00ee 80E0      		ldi r24,0
 658 00f0 0E94 0000 		call lcd_gotoxy
 659               	.LVL56:
 435:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 1);
 660               		.loc 1 435 0
 661 00f4 80E0      		ldi r24,lo8(.LC6)
 662 00f6 90E0      		ldi r25,hi8(.LC6)
 663 00f8 0E94 0000 		call lcd_puts
 664               	.LVL57:
 436:Lab7_Ex3_G09.c **** 
 665               		.loc 1 436 0
 666 00fc 61E0      		ldi r22,lo8(1)
 667 00fe 80E0      		ldi r24,0
 668 0100 0E94 0000 		call lcd_gotoxy
 669               	.LVL58:
 670 0104 5801      		movw r10,r16
 440:Lab7_Ex3_G09.c ****             while (idx < 10) 
 671               		.loc 1 440 0
 672 0106 F12C      		mov r15,__zero_reg__
 673               	.LVL59:
 674               	.L26:
 675               	.LBB42:
 447:Lab7_Ex3_G09.c **** 
 676               		.loc 1 447 0 discriminator 1
 677 0108 0E94 0000 		call keypad_getkey
 678               	.LVL60:
 679 010c 8823      		tst r24
 680 010e 01F0      		breq .L26
 450:Lab7_Ex3_G09.c **** 
 681               		.loc 1 450 0
 682 0110 8332      		cpi r24,lo8(35)
 683 0112 01F0      		breq .L27
 453:Lab7_Ex3_G09.c **** 
 684               		.loc 1 453 0
 685 0114 F501      		movw r30,r10
 686 0116 8193      		st Z+,r24
 687 0118 5F01      		movw r10,r30
 456:Lab7_Ex3_G09.c **** 
 688               		.loc 1 456 0
 689 011a 0E94 0000 		call lcd_putc
 690               	.LVL61:
 459:Lab7_Ex3_G09.c ****             }
 691               		.loc 1 459 0
 692 011e F394      		inc r15
 693               	.LVL62:
 694               	.LBE42:
 441:Lab7_Ex3_G09.c ****             {   
 695               		.loc 1 441 0
 696 0120 FAE0      		ldi r31,lo8(10)
 697 0122 FF12      		cpse r15,r31
 698 0124 00C0      		rjmp .L26
 699               	.LVL63:
 700               	.L27:
 463:Lab7_Ex3_G09.c **** 
 701               		.loc 1 463 0
 702 0126 6F2C      		mov r6,r15
 703 0128 712C      		mov r7,__zero_reg__
 704 012a F801      		movw r30,r16
 705 012c E60D      		add r30,r6
 706 012e F71D      		adc r31,r7
 707 0130 1082      		st Z,__zero_reg__
 708               	.LVL64:
 709 0132 4601      		movw r8,r12
 710               	.LBB43:
 466:Lab7_Ex3_G09.c ****             {   
 711               		.loc 1 466 0
 712 0134 5801      		movw r10,r16
 713               	.LVL65:
 714               	.L29:
 466:Lab7_Ex3_G09.c ****             {   
 715               		.loc 1 466 0 is_stmt 0 discriminator 1
 716 0136 8A2D      		mov r24,r10
 717 0138 801B      		sub r24,r16
 718 013a 8F15      		cp r24,r15
 719 013c 00F0      		brlo .L30
 720               	.LBE43:
 473:Lab7_Ex3_G09.c **** 
 721               		.loc 1 473 0 is_stmt 1
 722 013e F601      		movw r30,r12
 723 0140 E60D      		add r30,r6
 724 0142 F71D      		adc r31,r7
 725 0144 1082      		st Z,__zero_reg__
 476:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 0);
 726               		.loc 1 476 0
 727 0146 0E94 0000 		call lcd_clrscr
 728               	.LVL66:
 477:Lab7_Ex3_G09.c ****             lcd_puts("Encrypted:");
 729               		.loc 1 477 0
 730 014a 60E0      		ldi r22,0
 731 014c 80E0      		ldi r24,0
 732 014e 0E94 0000 		call lcd_gotoxy
 733               	.LVL67:
 478:Lab7_Ex3_G09.c ****             lcd_gotoxy(0, 1);
 734               		.loc 1 478 0
 735 0152 80E0      		ldi r24,lo8(.LC7)
 736 0154 90E0      		ldi r25,hi8(.LC7)
 737 0156 0E94 0000 		call lcd_puts
 738               	.LVL68:
 479:Lab7_Ex3_G09.c ****             lcd_puts(encrypted_text);
 739               		.loc 1 479 0
 740 015a 61E0      		ldi r22,lo8(1)
 741 015c 80E0      		ldi r24,0
 742 015e 0E94 0000 		call lcd_gotoxy
 743               	.LVL69:
 480:Lab7_Ex3_G09.c ****             _delay_ms(3000);
 744               		.loc 1 480 0
 745 0162 C601      		movw r24,r12
 746 0164 0E94 0000 		call lcd_puts
 747               	.LVL70:
 748               	.LBB44:
 749               	.LBB41:
 187:/usr/lib/avr/include/util/delay.h **** 
 750               		.loc 2 187 0
 751 0168 FFEF      		ldi r31,lo8(9599999)
 752 016a 2BE7      		ldi r18,hi8(9599999)
 753 016c 32E9      		ldi r19,hlo8(9599999)
 754 016e F150      	1:	subi r31,1
 755 0170 2040      		sbci r18,0
 756 0172 3040      		sbci r19,0
 757 0174 01F4      		brne 1b
 758 0176 00C0      		rjmp .L42
 759               	.LVL71:
 760               	.L30:
 761               	.LBE41:
 762               	.LBE44:
 763               	.LBB45:
 469:Lab7_Ex3_G09.c ****             }
 764               		.loc 1 469 0 discriminator 3
 765 0178 6E2D      		mov r22,r14
 766 017a F501      		movw r30,r10
 767 017c 8191      		ld r24,Z+
 768 017e 5F01      		movw r10,r30
 769 0180 0E94 0000 		call caesar_cipher
 770               	.LVL72:
 771 0184 F401      		movw r30,r8
 772 0186 8193      		st Z+,r24
 773 0188 4F01      		movw r8,r30
 774 018a 00C0      		rjmp .L29
 775               	.LBE45:
 776               	.LBE46:
 777               		.cfi_endproc
 778               	.LFE12:
 780               	.global	keymap
 781               		.section	.rodata
 784               	keymap:
 785 000c 31        		.byte	49
 786 000d 32        		.byte	50
 787 000e 33        		.byte	51
 788 000f 41        		.byte	65
 789 0010 34        		.byte	52
 790 0011 35        		.byte	53
 791 0012 36        		.byte	54
 792 0013 42        		.byte	66
 793 0014 37        		.byte	55
 794 0015 38        		.byte	56
 795 0016 39        		.byte	57
 796 0017 43        		.byte	67
 797 0018 2A        		.byte	42
 798 0019 30        		.byte	48
 799 001a 23        		.byte	35
 800 001b 44        		.byte	68
 801               		.text
 802               	.Letext0:
 803               		.file 3 "/usr/lib/avr/include/stdint.h"
 804               		.file 4 "lcd.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Lab7_Ex3_G09.c
      Lab7_Ex3_G09.s:2      *ABS*:000000000000003e __SP_H__
      Lab7_Ex3_G09.s:3      *ABS*:000000000000003d __SP_L__
      Lab7_Ex3_G09.s:4      *ABS*:000000000000003f __SREG__
      Lab7_Ex3_G09.s:5      *ABS*:0000000000000000 __tmp_reg__
      Lab7_Ex3_G09.s:6      *ABS*:0000000000000001 __zero_reg__
      Lab7_Ex3_G09.s:12     .text:0000000000000000 EEPROMwrite
      Lab7_Ex3_G09.s:44     .text:0000000000000010 EEPROMread
      Lab7_Ex3_G09.s:74     .text:000000000000001e caesar_cipher
      Lab7_Ex3_G09.s:134    .text:0000000000000056 keypad_init
      Lab7_Ex3_G09.s:178    .text:000000000000006c keypad_getkey
      Lab7_Ex3_G09.s:784    .rodata:000000000000000c keymap
      Lab7_Ex3_G09.s:465    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__divmodhi4
lcd_init
lcd_clrscr
lcd_gotoxy
lcd_puts
lcd_putc
__do_copy_data
